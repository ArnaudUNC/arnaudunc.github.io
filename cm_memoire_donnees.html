<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MÃ©moire et modÃ¨le de donnÃ©es | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E ğŸ %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		ğŸ

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_spec_impl_versions.html">
				SpÃ©cification, implÃ©mentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_methodes_exec.html">
				FaÃ§ons d'exÃ©cuter un programme Python
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_memoire_donnees.html">
				MÃ©moire et modÃ¨le de donnÃ©es
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_sequences.html">
				Les sÃ©quences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancÃ©es sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramÃ¨tres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_compr_listes.html">
				ComprÃ©hension de listes
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="td1.html">
				âœï¸ TD 1 - Calculatrice niv.1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp1.html">
				âœï¸ TP 1 - Calculatrice niv.2 (âœ”ï¸)
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="td2.html">
				âœï¸ TD 2 - Prog. objets niv.1 (âœ”ï¸)
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp2.html">
				âœï¸ TP 2 - Calculatrice niv.3
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cc1_2023.html">
				ğŸ“ ContrÃ´le continu 1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="td3.html">
				âœï¸ TD 3 (âœ”ï¸)
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp3.html">
				âœï¸ TP 3 - Calculatrice niv.4
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp4.html">
				âœï¸ TP 4 - Prog. objets niv.2
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp5.html">
				âœï¸ TP 5 - Prog. objets niv.3
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	
	<h1 data-nb="6" id="MÃ©moire et modÃ¨le de donnÃ©es">MÃ©moire et modÃ¨le de donnÃ©es</h1>
<p>Creusons un peu plus dans les notions fondamentales en Python que sont les objets, les types de donnÃ©es et la mÃ©moire de l'ordinateur.</p>

	
	<h2 data-nb="6.1" id="Objets">Objets</h2>
<p>Toute forme de donnÃ©e en Python est reprÃ©sentÃ©e par des <strong>objets</strong>, que Ã§a soit les nombres, les chaÃ®nes de caractÃ¨res, les listes, les
		tuples etc... MÃªme les fonctions sont reprÃ©sentÃ©es sous forme d'objets.</p>
<p>Par exemple le <code>int</code> <code>5</code> est un objet, tout comme la <code>str</code> <code>"bonjour"</code>, le <code>bool</code>
<code>True</code> ou la liste <code>[3, 10, 8]</code>.</p>
<p>Les objets existent dans un espace mÃ©moire qui leur est rÃ©servÃ©.</p>
<p>Voici donc conceptuellement comment les donnÃ©es d'un programme en Python sont reprÃ©sentÃ©es</p>
<img alt="" src="img/memoire_modele_donnees/objets_simples2.png"/>
<p>Le terme <em>objet</em> fait rÃ©fÃ©rence Ã  la <em>Programmation OrientÃ©e Objet</em> (POO), quâ€™on appelle aussi <em>Programmation Objet</em> (PO), qui est
		une faÃ§on de reprÃ©senter et manipuler les donnÃ©es dans un programme. On verra plus tard un peu plus en dÃ©tail, pour l'instant retenons que cette
		approche a ses avantages et inconvÃ©nients, mais un avantage est quâ€™elle imite la faÃ§on dâ€™un Ãªtre humain de penser et conceptualiser les choses, et non
		pas comme une machine reprÃ©sente les donnÃ©es dans sa mÃ©moire. Avec la programmation objets, la machine sâ€™adapte Ã  lâ€™Homme, et pas lâ€™inverse. </p>
<p>Un dÃ©savantage de lâ€™approche objets est une abstraction plus Ã©levÃ©e dans la maniÃ¨re de reprÃ©senter les donnÃ©e dans un programme, ce qui demande un effort
		ce conception de la part du dÃ©veloppeur plus important par rapport Ã  une reprÃ©sentation plus proche de celle de la machine. En gÃ©nÃ©ral le bÃ©nÃ©fice de la
		PO est plus important que son coÃ»t, mais un Ã©quilibre doit Ãªtre maintenu entre bÃ©nÃ©fice et coÃ»t.</p>

	
	<h2 data-nb="6.2" id="Types, classes et valeurs">Types, classes et valeurs</h2>
<p>Chaque objet a un <strong>type</strong>, et une <strong>valeur</strong>. Le type dÃ©termine les valeurs possibles que l'objet pourra avoir, par exemple un
		objet de type <code>int</code> peut avoir la valeur <code>5</code>, ou s'il est de type <code>str</code> il peut avoir la valeur <code>"Bonjour</code>.
		Le type dÃ©termine aussi les opÃ©rations possibles sur cet objet, par exemple faire une addition si c'est un <code>int</code>, le mettre en majuscule pour
		une <code>str</code>, ou avoir sa longueur si c'est un <code>list</code>. Le type d'un objet est dÃ©finitif et ne peux Ãªtre changÃ©. Sa valeur par contre
		peut Ãªtre ou ne pas Ãªtre modifiable, Ã§a va dÃ©pendre du type de l'ojet, on verra Ã§a plus en dÃ©tails plus bas.</p>
<p>Ainsi, notre reprÃ©sentation des donnÃ©es d'un programme en Python devient:</p>
<img alt="" src="img/memoire_modele_donnees/objets_types_valeurs2.png"/>
<p>Notez qu'on Ã©crit les valeurs avec leur forme littÃ©rale, par exemple <code>"Bonjour"</code>, c'est une faÃ§on d'Ã©crire facile pour un Ãªtre humain Ã  la
		fois pour lire et Ã©crire, mais Python reprÃ©sente les donnÃ©es sous sa propre forme interne, avec des bits et des octets. En tant qu'utilisateur de Python
		nous n'avons en gÃ©nÃ©ral pas Ã  nous soucier des dÃ©tails internes de comment Python reprÃ©sente les donnÃ©es techniquement dans la mÃ©moire de l'ordinateur.
		Il est cependant utile de comprendre comment tout cela fonctionne dans son ensemble.</p>
	
	<table>
<tr>
<td style="padding:1em;"><strong>Valeur littÃ©rale en Python</strong></td>
<td style="padding:1em;"><strong>ReprÃ©sentation binaire rÃ©elle en mÃ©moire</strong></td>
</tr>
<tr>
<td style="padding:1em;">"Bonjour"</td>
<td style="padding:1em;">0010011...01110101</td>
</tr>
<tr>
<td style="padding:1em;">5</td>
<td style="padding:1em;">1010011...10111</td>
</tr>
</table>
<p>On peut obtenir le type d'un objet avec la fonction <code>type()</code>, qui prend en paramÃ¨tre n'importe quel objet, et retourne son type sous forme
		Ã©galement d'un objet qui reprÃ©sente ce type, car les types eux-mÃªmes sont aussi reprÃ©sentÃ©s par des objets. En programmation objet on appelle un type
		une <strong>classe</strong>, ou <strong>class</strong> en anglais. Les mots <em>type</em> et <em>classe</em> sont synonymes.</p>
<pre><code class="language-python">
		&gt;&gt;&gt; type(5)
		&lt;class 'int'&gt;

		&gt;&gt;&gt; type("Bonjour")
		&lt;class 'str'&gt;

		&gt;&gt;&gt; type(-3.2)
		&lt;class 'float'&gt;

		&gt;&gt;&gt; type(False)
		&lt;class 'bool'&gt;
	</code></pre>
<p>On peut aussi avoir le type des objets types eux-mÃªmes, en appelant <code>type()</code> sur un objet rÃ©sultat d'un autre appel Ã  <code>type()</code>:</p>
<pre><code class="language-python">
		&gt;&gt;&gt; type(type(5))
		&lt;class 'type'&gt;

		&gt;&gt;&gt; type(type("Bonjour"))
		&lt;class 'type'&gt;

		&gt;&gt;&gt; type(type(-3.2))
		&lt;class 'type'&gt;

		&gt;&gt;&gt; type(type(False))
		&lt;class 'type'&gt;

		&gt;&gt;&gt; type(type(type(False)))
		&lt;class 'type'&gt;
	</code></pre>
<p>On peut voir â†‘ que tous les types sont reprÃ©sentÃ©s par des objets de type <em>type</em> (qui n'ont pas forcÃ©ment la mÃªme valeur en revanche, s'ils
		reprÃ©sentent des types diffÃ©rents). Le type <em>type</em> lui-mÃªme est un objet qui a lui-mÃªme pour type, il est de son propre type.</p>
<p>Une classe, comme toute donnÃ©e, est reprÃ©sentÃ©e en mÃ©moire rÃ©ellement par des bits et octets, Python la reprÃ©sente sous forme d'objet, et quand on
		souhaite la reprÃ©senter sous forme de texte, par dÃ©faut Python met le mot <code>class</code> suivi du nom de la classe entre simples guillemets, le tout
		entourÃ© des caractÃ¨res <code>&lt;</code> et <code>&gt;</code>, par exemple <code>&lt;class 'int'&gt;</code></p>
<p>Pour savoir si deux objets ont le mÃªme type, on peut comparer la valeur de leurs types correspondants avec l'opÃ©rateur <code>==</code>:</p>
<pre><code class="language-python">
		&gt;&gt;&gt; type(5) == type(10)
		True

		&gt;&gt;&gt; type(5) == type("Bonjour")
		False
	</code></pre>

	
	<h2 data-nb="6.3" id="Variables / identifiants">Variables / identifiants</h2>
<p>Une "variable" en Python est appelÃ©e un "nom" ("name" en anglais), mais on peut aussi utiliser le terme "identifiant", les trois (variable, nom et
		identifiant) sont des synonymes. Un identifiant ne contient pas de valeur, ne contient pas d'objet, mais <strong>pointe vers</strong> un objet, on dit
		aussi qu'un identifiant <em>fait rÃ©fÃ©rence</em> Ã  un objet, ou <em>rÃ©rÃ©rence</em> un objet.</p>
<p>Les identifiants sont crÃ©Ã©s et modifiÃ©s Ã  l'aide de l'instruction d'affectation <code>=</code>. Ils existent dans un espace mÃ©moire sÃ©parÃ© de celui des
		objets, qu'on appelle <a href="cm_namespaces_modules.html">namespace</a>, "espace de noms" en franÃ§ais.</p>
<p>Prenons par exemple la ligne suivante, et voyons ce que Python fait avec les identifiants et objets:</p>
<pre><code class="language-python">
		a = 5
	</code></pre>
<p>1 - Au tout dÃ©but la mÃ©moire est vide. Nous avons deux catÃ©gories d'espaces en mÃ©moire : celui unique des objets, et la catÃ©gorie des espaces des
		identifiants:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_1_2.png"/>
<p>2 - L'expression Ã  droite du <code>=</code> est Ã©valuÃ©e. Elle peut Ãªtre complexe, ou simple comme dans cet exemple, puisqu'il s'agit d'un unique littÃ©ral
		<code>int</code>. L'objet qui a pour valeur le rÃ©sultat de cette expression, ainsi que le type correspondant, est crÃ©Ã©, donc ici un objet ayant pour
		type <code>int</code> et pour valeur <code>5</code>:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_2_2.png"/>
<p>3 - L'identifiant <code>a</code> est crÃ©Ã©, puisqu'il n'existe pas encore:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_3_2.png"/>
<p>4 - <code>a</code> est modifiÃ© pour pointer vers l'objet Ã  droite du <code>=</code>:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_4_2.png"/>
<p>Si ensuite on fait:</p>
<pre><code class="language-python">
		a = a + 1
	</code></pre>
<p>5 - L'expression Ã  droite du <code>=</code> est Ã©valuÃ©e, un nouvel objet est crÃ©Ã© qui a pour valeur le rÃ©sultat de cette expression ainsi que le type
		correspondant, donc ici un objet ayant pour type <code>int</code> et pour valeur <code>6</code>:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_5_2.png"/>
<p>6 - <code>a</code> est modifiÃ© pour pointer vers l'objet Ã  droite du <code>=</code>. De plus, le mÃ©canisme de <em>garbage collector</em> qu'on verra plus
		en dÃ©tails ensuite nettoie automatiquement la mÃ©moire, et supprime l'objet qui n'est plus accessible par aucun identifiant:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_6_2.png"/>
<p>Les identifiants peuvent Ãªtre supprimÃ©s manuellement Ã  l'aide de l'instruction <code>del</code> (diminutif de <em>delete</em> qui veut dire
		<em>supprimer</em> en anglais). On verra plus tard qu'ils sont la majoritÃ© du temps supprimÃ©s automatiquement par les <em>namespaces</em>, on n'a
		gÃ©nÃ©ralement pas Ã  s'occuper nous-mÃªmes de la destruction des identifiants. Mais si on fait:</p>
<pre><code class="language-python">
		del a
	</code></pre>
<p>7 - <code>a</code> est supprimÃ©:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_7_2.png"/>
<p>8 - L'objet n'est plus rÃ©fÃ©rencÃ© par aucun identifiant, le garbage collector le supprime automatiquement:</p>
<img alt="" src="img/memoire_modele_donnees/identifiant_creation_8.png"/>

	
	<h2 data-nb="6.4" id="Le cas des listes et des tuples">Le cas des listes et des tuples</h2>
<p>Les listes et les tuples sont des types qui contiennent plusieurs valeurs. Ces valeurs ne sont pas DANS les objets liste ou tuples, mais sont des objets
		distincts, rÃ©fÃ©rencÃ©s par la liste ou le tuple en question. Les listes et tuples sont en quelque sorte des suites de pointeurs. Voyons quelques exemples
		de listes, et leur reprÃ©sentation en mÃ©moire.</p>
<p>Une liste vide:</p>
<pre><code class="language-python">
		ma_liste = []
	</code></pre>
<img alt="" src="img/memoire_modele_donnees/liste_vide.png"/>
<p>Une liste qui "contient" plusieurs objets distincts:</p>
<pre><code class="language-python">
		ma_liste = [8, "Salut", True, None]
	</code></pre>
<img alt="" src="img/memoire_modele_donnees/liste_objets_distincts.png"/>
<p>Une liste qui "contient" plusieurs objets identiques:</p>
<pre><code class="language-python">
		a = 8
		ma_liste = [a, "Salut", a, None]
	</code></pre>
<img alt="" src="img/memoire_modele_donnees/liste_objets_identiques.png"/>
<p>En <a href="cm_spec_impl_versions.html">CPython</a>, certains objets immutables (voir plus bas) sont uniques en mÃ©moire, en particulier les
		<code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code> et certaines <code>str</code> courtes. Par exemple:</p>
<pre><code class="language-python">
		a = 8
		ma_liste = [a, 8, True, True]
	</code></pre>
<img alt="" src="img/memoire_modele_donnees/liste_objets_identiques2.png"/>
<p>Une liste peut pointer vers d'autres listes:</p>
<pre><code class="language-python">
		ma_liste = [8, [8, 2], 0]
	</code></pre>
<img alt="" src="img/memoire_modele_donnees/liste_dans_liste.png"/>

	
	<h2 data-nb="6.5" id="IdentitÃ©">IdentitÃ©</h2>
<p>Tout objet en Python a une identitÃ© reprÃ©sentÃ©e par un nombre entier qui doit Ãªtre unique au sein d'un programme en cours d'exÃ©cution. L'identitÃ© d'un
		objet est dÃ©finitive et ne peux Ãªtre changÃ©e au cours de l'existence de l'objet. Ainsi, notre reprÃ©sentation des donnÃ©es d'un programme en Python
		devient: </p>
<img alt="" src="img/memoire_modele_donnees/objets_type_val_et_id_2.png"/>
<p>Les identitÃ© des objets dans ce schÃ©ma sont juste des exemples arbitraires.</p>
<p>Plusieurs objets peuvent avoir la mÃªme identitÃ©, mais ils ne doivent pas exister en mÃªme temps. Par exemple si pendant l'exÃ©cution d'un programme un
		objet a l'identitÃ© 10, aucun autre objet ne peut avoir l'identitÃ© 10 tant qu'il existe. Quand cet objet est dÃ©truit, alors Ã  ce moment l'identitÃ© 10 peu
		Ã  nouveau Ãªtre utilisÃ© par un nouvel objet, qui sera probablement d'un type diffÃ©rent et avec une valeur diffÃ©rente du prÃ©cÃ©dent objet qui avait la mÃªme
		identitÃ©.</p>
<img alt="" src="img/memoire_modele_donnees/objets_id_timeline_2.png"/>
<p>Pour obtenir l'identitÃ© de tout objet, on utilise la fonction <code>id()</code>, qui prend n'importe quel objet en paramÃ¨tre, et retourne son identitÃ©
		sous forme de <code>int</code>. En <a href="cm_spec_impl_versions.html">CPython</a>, l'identitÃ© d'un objet est son adresse en mÃ©moire. Cette adresse
		dÃ©pend de nombreux facteurs qui sont en dehors de notre contrÃ´le, et qui ne sont pas importants pour nous, car c'est Python qui gÃ¨re la mÃ©moire pour
		nous, il est donc normal que les adresses mÃ©moire des objets varient d'une exÃ©cution du programme Ã  une autre, mÃªme si le programme fait exactement la
		mÃªme chose Ã  chaque fois.</p>
<pre><code class="language-python">
		&gt;&gt;&gt; id(5)
		1997577388400

		&gt;&gt;&gt; a = "Bonjour"
		&gt;&gt;&gt; id(a)
		1997648895024
	</code></pre>
<p>Pour savoir si deux objets sont en fait le mÃªme objet, on utilise l'opÃ©rateur binaire <code>is</code> qui vaut <code>True</code> si les objets Ã  droite
		et Ã  gauche sont le mÃªme objet, <code>False</code> sinon. Dans l'exemple suivant on a deux identifiants <code>a</code> et <code>b</code> qui rÃ©fÃ©rencent
		le mÃªme objet de type <code>int</code> qui a pour valeur <code>5</code>, <code>is</code> permet de le confirmer:</p>
<img alt="" src="img/memoire_modele_donnees/operateur_is_exemple_2.png"/>
<pre><code class="language-python">
		&gt;&gt;&gt; a = 5
		&gt;&gt;&gt; b = a
		&gt;&gt;&gt; a is b
		True
	</code></pre>
<p><code>is</code> est Ã©quivalent Ã  comparer les identitÃ©s des deux objets avec l'opÃ©rateur <code>==</code>:</p>
<pre><code class="language-python">
		&gt;&gt;&gt; a = 5
		&gt;&gt;&gt; b = a
		&gt;&gt;&gt; a is b
		True

		&gt;&gt;&gt; id(a)
		200
		&gt;&gt;&gt; id(b)
		200
		&gt;&gt;&gt; id(a) == id(b)
		True
	</code></pre>
<p>On peut aussi utiliser "is" pour confirmer le type exact d'un objet. Pour savoir si deux objets ont le mÃªme type, on a vu qu'on peut comparer leurs types
		avec l'opÃ©rateur <code>==</code> mais c'est encore plus prÃ©cis avec l'opÃ©rateur <code>is</code> car on vÃ©rifie que leurs types sont en fait le MÃŠME
		objet (souvenez-vous les types sont aussi reprÃ©sentÃ©s par des objets):</p>
<pre><code class="language-python">
		&gt;&gt;&gt; type(5) == type(10)
		True

		&gt;&gt;&gt; type(5) is type(10)
		True

		&gt;&gt;&gt; type(5) is int
		True
	</code></pre>
<h3 data-nb="6.5.1" id="DiffÃ©rence entre == et is">DiffÃ©rence entre == et is</h3>
<p>"==" permet de comparer la VALEUR de deux objets, et vaut vrai si la valeur de l'objet Ã  gauche du "==" est Ã©gale Ã  celle de l'objet Ã  sa droite.</p>
<p>"is" permet de comparer l'IDENTITE de deux objets, et vaut vrai si l'identitÃ© de l'objet Ã  gauche du "is" est Ã©gale Ã  celle de l'objet Ã  sa droite.</p>

	
	<h2 data-nb="6.6" id="Les types builtin, mutables et immutables">Les types <em>builtin</em>, mutables et immutables</h2>
<p>On appelle les types <em>builtin</em> tous les types qui sont dÃ©finis dans Python directement (en particulier dans le module <code>builtins</code>, mais
		pas uniquement), en opposition Ã  ceux dÃ©finis par nous-mÃªme ou par des bibliothÃ¨ques de code externes Ã  Python.</p>
<p>La valeur des objets de certains types PEUT changer au cours de leur existence, on dit de ces objets qu'ils sont <em>mutables</em> (de l'anglais <em>mutable</em>)
		ou plus rarement <em>muables</em>. Au contraire les objets dont le type interdit le changement de valeur au cours de leur existence sont dits <em>immuables</em>
		ou <em>immutables</em> (de l'anglais <em>immutable</em>). On peut aussi qualifier les types eux-mÃªmes de <em>mutable</em> ou <em>immutable</em>, Ã§a
		revient au mÃªme.</p>
<p> Jusqu'Ã  prÃ©sent dans ce cours, vous n'avez vu que des types builtin, qui sont:</p>
<ul>
<li><p><code>NoneType</code> dont l'unique valeur est None, qui reprÃ©sente l'absence de valeur, immutableğŸ”’</p></li>
<li><p><code>int</code> pour les nombres entiers, immutableğŸ”’</p></li>
<li><p><code>float</code> pour les nombres rÃ©els, immutableğŸ”’</p></li>
<li><p><code>str</code> pour les chaÃ®nes de caractÃ¨res, immutableğŸ”’</p></li>
<li><p><code>bool</code> pour les boolÃ©ens, immutableğŸ”’</p></li>
<li><p><code>tuple</code> pour les tuples, immutableğŸ”’</p></li>
<li><p><code>list</code> pour les listes, mutable (le seul type mutable que vous connaissez)</p></li>
</ul>
<p>Vous avez aussi vu deux autres types sans forcÃ©ment rÃ©aliser qu'il s'agit aussi de types:</p>
<ul>
<li><p><code>range</code> dont les objets dÃ©crivent des intervalles d'entiers, immutableğŸ”’</p></li>
<li><p><code>function</code> dont les objets contiennent le code des fonctions, immutableğŸ”’</p></li>
</ul>
<img alt="" src="img/memoire_modele_donnees/objets_mutables_et_immutables.png"/>
<p>Et nous avons vu type un supplÃ©mentaire dans cette partie du cours, qui est le type <em>type</em> lui-mÃªme:</p>
<ul>
<li><p><code>type</code> dont les objets contiennent les types eux-mÃªmes, immutable</p></li>
</ul>

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E ğŸ %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la premiÃ¨re ligne des <pre><code> qui est considÃ©rÃ©e toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un Ã©lÃ©ment dÃ©truit tous ses Ã©lÃ©ments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un Ã©lÃ©ment texte
	});

	// On ajoute un <br> avant et aprÃ¨s chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.notÃ©');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>â†“ Affichage dans la console (ou dans le shell, selon oÃ¹ vous lancez l'exÃ©cution)<mall>`;
		p.classList.add("lÃ©gende_placÃ©e_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_Ã _cliquer">ğŸ“ Afficher / cacher correction âœ“</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
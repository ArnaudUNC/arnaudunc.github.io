<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Namespaces et modules | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_spec_impl_versions.html">
				Spécification, implémentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_methodes_exec.html">
				Façons d'exécuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_memoire_donnees.html">
				Mémoire et modèle de données
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_sequences.html">
				Les séquences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancées sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramètres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_compr_listes.html">
				Compréhension de listes
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="td1.html">
				✍️ TD 1 - Calculatrice niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp1.html">
				✏️ TP 1 - Calculatrice niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="td2.html">
				✍️ TD 2 - Prog. objets niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp2.html">
				✏️ TP 2 - Calculatrice niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cc1_2023.html">
				📝 Contrôle continu 1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="td3.html">
				✍️ TD 3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp3.html">
				✏️ TP 3 - Calculatrice niv.4 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp4.html">
				✏️ TP 4 - Prog. objets niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp5.html">
				✏️ TP 5 - Prog. objets niv.3
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp6.html">
				✏️ TP 6 - Prog. objets niv.4
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp7.html">
				✏️ TP 7 - Prog. objets niv.5
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_1.html">
				✏️ TP 8 - Boutique niv.1
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_2.html">
				✏️ TP 9 - Boutique niv.2
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cc3_2023.html">
				📝 Contrôle continu 3
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	
	<h1 data-nb="8" id="Namespaces et modules">Namespaces et modules</h1>
<h2 data-nb="8.1" id="Namespaces">Namespaces</h2>
<p>On appelle <em>namespace</em> ou <em>espace de nommage</em> en français, un mécanisme en Python qui isole les identifiants dans des espaces différents.
		Ils sont utiles pour aider à l'organisation du code et des identifiants en unités logiques plus facile à gérer car isolées les unes des autres, plutôt
		que de mettre tous les identifiants dans un seul et unique sac, cela serait vite ingérable. Par exemple dans un namespace A on peut avoir les
		identifiants a, b et c, qui ne seront pas les mêmes que les identifiants a, b et dans un namespace B. </p>

	

	<p>On définit des namespaces à chaque fois qu'on crée une fonction, une classe ou un module. Chaque instance des classes, donc chaque objet, sont aussi des
		namespaces. Pour les fonctions, l'espace de nommage qu'une fonction définit est créé à chaque fois que la fonction démarre son exécution, et détruit à
		chaque fois qu'elle se termine. Les classes quant à elles ont leur espace de nommage créé dès que le module dans lequel elles existent est importé.
		(Plus techniquement les namespaces sont liés à la notion d'objet, car chaque namespace est en fait un objet, et chaque objet est un namespace, les deux
		notions sont liées, une instance et les identifiants dans un namespace sont les attributs de cet objet)</p>

	

	
	<h2 data-nb="8.2" id="Modules et packages">Modules et packages</h2>
<p>Jusqu’ici on a créé des programmes Python dans un seul fichier <code>.py</code>. Au fur et à mesure qu’un programme devient long et complexe, le fichier
		devient difficile à naviguer et à lire, à ce moment on sépare le code dans plusieurs fichiers <code>.py</code>. Le mécanisme de Python qui permet de
		faire cela est celui des <em>modules</em> avec <em>l'importation</em>. On appelle <strong><em>module</em></strong> un fichier <code>.py</code> tout
		simplement. On appelle <strong><em>importation</em></strong> le fait de rendre disponible le contenu d'un module depuis un autre.</p>

	

	<p>Quels morceaux du code vont dans quels fichiers sont au choix des développeurs, ainsi que le nombre et le nom de ces fichiers. Python offre la
		possibilité de le faire, mais nous sommes libres d’utiliser cette fonctionnalité comme nous l’entendons. En général, on place le code lié à une même
		fonctionnalité, ou un même aspect du programme dans un même fichier, qui doit être le plus isolé et indépendant possible des autres fichiers et donc du
		reste du code.</p>
<p>On appelle aussi les modules <strong><em>bibliothèques</em></strong>, ou <strong><em>librairies</em></strong>. Elles peuvent être dans un seul fichier,
		ou bien dans un ensemble de fichiers cohérents dans le cas de grosses bibliothèques. On appelle <em>packages</em> un ensemble de modules dans un même
		dossier, ils sont un moyen de structurer les modules. mais on ne les verra pas dans ce cours. Ils sont cependant un aspect important de Python à étudier
		plus tard.</p>

	

	<p> Quand une bibliothèque comporte plusieurs fichiers, ils peuvent être inter-dépendants, c’est à dire qu’ils se référencent les uns les autres, mais
		idéalement le moins possible. En revanche, ils doivent être le plus indépendants possible de tout code hors de la bibliothèque, idéalement 100%
		indépendants de l'extérieur.</p>
<p>Le gros avantage lorsqu’on met du code dans des bibliothèques sous forme de modules ou packages, est qu’on peut le réutiliser où on veut, depuis
		n’importe quel autre fichier Python. On peut donc réutiliser des fonctions ou des classes, et éviter de devoir les ré-écrire ou les copier-coller dans
		plusieurs fichiers.</p>

	

	
	<h2 data-nb="8.3" id="Exemple">Exemple</h2>
<p>Voyons un exemple de modules: soit les deux modules suivants dans un même dossier:</p>
<pre><code class="language-treeview">
		Un dossier/
		|-- modA.py
		|-- modB.py
	</code></pre>
<pre><code class="language-python">
		# Ceci est le fichier modA.py, c'est donc le module modA

		variable = 'Bonjour modA'

		def f():
			print("Une fonction dans modA")
	</code></pre>
<p>Avec l'instruction <code>import</code> on peut importer un module dans un autre, pour avoir ensuite accès à ses variables et fonctions, en préfixant leur
		nom par celui du module suivi d'un point, comme par exemple <code>modA.variable</code>.</p>
<pre><code class="language-python">
		# Ceci est le fichier modB.py, c'est donc le module modB

		# On importe modA, remarquez qu'on ne met pas .py à la fin
		import modA

		variable = 'Bonjour modB'

		# ↓ Affichera 'Bonjour modB'
		print(variable)

		# ↓ Affichera 'Bonjour modA'
		print(modA.variable)

		# ↓ Affichera 'Une fonction dans modA'
		modA.f()
	</code></pre>
<p>Grâce à la notion de namespaces les deux modules peuvent contenir des identifiants ayant le même nom (<code>variable</code> ou <code>f</code>), et
		pourtant ils ne sont pas les mêmes, ils référencent des objets différents.</p>
<p>(schéma des deux modules modA et modB et leurs identifiants)</p>

	
	<h2 data-nb="8.4" id="L'instruction import">L'instruction <code>import</code></h2>
<p>Après qu'un module est importé, un identifiant qui porte son nom est créé dans le namespace où l'instruction <code>import</code> se situe (dans l'exemple
		ci-dessous le nom "modA" est créé par le "import"). Cet identifiant pointe vers un objet nouvellement créé de type <code>module</code> correspondant au
		module importé, objet par lequel on accèdera au module importé (le module modA.py dans l'exemple ci-dessous). C'est donc par cet objet qu'on peut
		accéder au namespace du module que l'objet représente, et donc à tous les noms présents dans ce module.</p>
<pre><code class="language-python">
		# Ceci est le fichier modB.py
		import modA

		print(modA)
		print(type(modA))
	</code></pre>
<p>Executons <code>modB.py</code>:</p>
<pre class="affichage_console"><code>
&lt;module 'modA' from 'C:\\Users\\Arnaud\\Desktop\\modA.py'&gt;
&lt;class 'module'&gt;
</code></pre>
<p>On place généralement les instructions <code>import</code> tout en haut des fichiers, mais ils peuvent apparaître n'importe où. </p>
	

	

	
	<h3 data-nb="8.4.1" id="Boucles d'importation">Boucles d'importation</h3>
<p>Attention à ne pas créer de boucles dans les importations, c'est à dire deux modules ou plus qui s'importent mutuellement:</p>
<pre><code class="language-python">
		# Ceci est le fichier modA.py
		import modB # &lt;= ERREUR: boucle avec import dans modB
	</code></pre>
<pre><code class="language-python">
		# Ceci est le fichier modB.py
		import modA # &lt;= ERREUR: boucle avec import dans modA
	</code></pre>

	
	<h3 data-nb="8.4.2" id="Mécanisme d'importation">Mécanisme d'importation</h3>
<p>La première fois qu'un module est importé, tout son contenu est exécuté une fois. Pour cette raison importer plusieurs fois le même module, que ça soit
		depuis le même module ou depuis plusieurs modules, n'a aucun coût en terme de performances.</p>

	

	<p>Si on execute <code>modB.py</code> ci-dessous, on aura à l'affichage <code>modA exécuté</code> ↓</p>
<pre><code class="language-python">
		# fichier modA.py
		print("modA exécuté")
	</code></pre>
<pre><code class="language-python">
		# fichier modB.py, on execute celui-ci
		import modA
		import modA # &lt;= pas d'erreur, mais inutile
	</code></pre>
<p>Dans un module qui est sert de "stockage" de variables, fonctions et classes, on évite de mettre des instructions globales autres que des déclaration de
		variables, fonctions et classes hors de toute fonction, car elles seront exécutées lors de la première importation. Cela peut avoir des effets de bords
		indésirables pour le développeur qui importera le module. Donc dans un module qui sert de bibliothèque à importer on ne met <strong>surtout pas</strong>
		par exemple de code qui affiche avec <code>print()</code>, qui met en pause le programme avec <code>input()</code>, qui manipule des fichiers ou qui
		communique sur le réseau hors de fonctions. On met le code dans des fonctions, et le développeur importera le module puis appellera les fonctions
		qu'il/elle souhaite, afin de garder la maîtrise du déroulement du programme.</p>

	

	
	<h2 data-nb="8.5" id="L'identifiant __name__ et le module __main__">L'identifiant <code>__name__</code> et le module <code>__main__</code></h2>
<p>Chaque module contient un identifiant pré-défini <code>__name__</code> (avec double <code>_</code> de chaque côté) qui pointe vers un objet de type
		<code>str</code> qui a pour valeur le nom du module. Si on execute <code>modB.py</code> ci-dessous ↓</p>
<pre><code class="language-python">
		# fichier modA.py
		print(__name__)
	</code></pre>
<pre><code class="language-python">
		# fichier modB.py, on execute celui-ci
		import modA
		print(modA.__name__)
		print(__name__)
	</code></pre>
<pre class="affichage_console"><code>
modA
modA
__main__</code></pre>
<p>On peut voir que la variable "__name__" dans modA vaut bien "modA".</p>
<p>Par contre, remarquez une chose spéciale: ↑ la variable <code>__name__</code> dans <code>modB.py</code> ne vaut pas <code>"modB"</code> mais la string
		<code>"__main__"</code>. Le module qui est exécuté par le programme Python (par exemple avec la commande <code>python modB.py</code>), devient le module
		principal, le point d'entrée du programme, et son module prend le nom spécial <code>"__main__"</code>. Dans replit le module qui est exécuté est le
		fichier main.py par défaut, quand on clique sur le bouton <em>Run</em>.</p>







	
	<h2 data-nb="8.6" id="Le contexte global">Le contexte global</h2>
<p>Ce qu'on appelle d'habitude <em>contexte global</em> ou <em>environnement global</em>, pour désigner tout ce qui est extérieur à des fonctions et
		classes, est en fait global au module dans lequel on se situe. Il n'existe pas de contexte vraiment totalement global dans un programme, seulement des
		modules chacun ayant leur contexte global. Le véritable terme qu'on devrait employer serait <em>namespace du module</em>, mais par abus de langage on
		dit souvent <em>contexte global du module</em> ou <em>environnement global du module</em>.</p>

	
	<h2 data-nb="8.7" id="La fonction dir()">La fonction <code>dir()</code></h2>
<p>Vous pouvez lister le nom de tous les éléments déclarés dans un module avec la fonction <a href="https://docs.python.org/fr/3/library/functions.html?highlight=vars#dir"><code>dir()</code></a>, qui prend un objet en paramètre, et retourne
		une liste de tous les identifiants (sous forme de <code>str</code>) qui sont dans le namespace de l'objet. Exemple:</p>
<pre><code class="language-python">
		# fichier modA.py
		une_variable = 'a'
		def une_fonction():
			pass
	</code></pre>
<pre><code class="language-python">
		# fichier modB.py, on execute celui-ci
		import modA
		print(dir(modA))
	</code></pre>
<pre class="affichage_console"><code>
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__',
	'__package__', '__spec__', 'une_fonction', 'une_variable']</code></pre>
<p>↑ On obtient une liste de <code>str</code>, où chaque élément est le nom d'un identifiant: variable, fonction, classe etc.... Remarquez qu'il y a
		beaucoup d'identifiants pré-définies dans le module, ceux entourés de deux caractères underscore <code>_</code>, qu'on peut ignorer pour l'instant. Mais
		on retrouve la variable <code>__name__</code>, et on peut voir notre fonction <code>une_fonction</code> et notre variable <code>une_variable</code> à la
		fin.</p>
<p>Sans paramètres <code>dir()</code> retourne la liste de tous les identifiants dans le namespace dans lequel elle est appelée, donc par exemple dans le
		contexte global pour avoir les identifiants du module dans lequel elle est appelée.</p>

	
	<h2 data-nb="8.8" id="Les fonctions vars() et globals()">Les fonctions <code>vars()</code> et <code>globals()</code></h2>
<p><a href="https://docs.python.org/fr/3/library/functions.html?highlight=vars#vars">vars()</a> fait à peu près la même chose que <code>dir()</code> mais
		retourne un dictionnaire au lieu d'une liste, qui a pour clé les identifiants, et pour valeurs les objets associés. Soit pour un objet/namespace en
		particulier passé en paramètre, soit pour le namespace depuis lequel elle est appelée si aucun paramètre ne lui est passé.</p>
<p>La fonction prédéfinie <a href="https://docs.python.org/fr/3/library/functions.html?highlight=vars#globals"><code>globals()</code></a> est très similaire
		à <code>vars()</code> mais ne prend jamais aucun paramètre, et peu importe où elle est appelée elle retourne toujours tous les identifiants du contexte
		global du module dans lequel elle est appelée, et leurs objets associés, dans un dictionnaire comme pour <code>vars()</code>.</p>


	
	<h2 data-nb="8.9" id="Exemple">Exemple</h2>
<p>Prenons le code ci-dessous, et voyons les différents namespaces qui sont créés automatiquement:</p>
<h3 data-nb="8.9.1" id="Namespace du module, ou namespace global:">Namespace du module, ou namespace global:</h3>
<p>(Attention, les objets sont toujours stockés dans l'espace unique des objets (voir partie sur le <a href="cm_memoire_donnees.html">modèle de données</a>),
		mais pour rendre le schéma plus lisible les objets sont montrés éparpillés autour du namespace.)</p>
<p>Le namespace ci-dessous est celui une fois la totalité du fichier exécuté ou importé. C'est important de le préciser, car ligne après ligne des nouveaux
		identifiants sont créés et sont ajoutés dans le namespace du module, donc les noms présents ou pas dans un namespace à un point précis du programme
		dépendent des lignes qui ont été exécutées jusqu'à ce point.</p>
<img alt="" src="img/cm_namespaces/module.png"/>
<h3 data-nb="8.9.2" id="Namespace de la fonction f, ou namespace local à f:">Namespace de la fonction f, ou namespace local à f:</h3>
<p>(Attention, les objets sont toujours stockés dans l'espace unique des objets (voir partie sur le <a href="cm_memoire_donnees.html">modèle de données</a>),
		mais pour rendre le schéma plus lisible les objets sont montrés éparpillés autour du namespace.)</p>
<img alt="" src="img/cm_namespaces/fonction_f.png"/>
<h3 data-nb="8.9.3" id="Namespace du constructeur __init__ de la classe:">Namespace du constructeur __init__ de la classe:</h3>
<p>(Attention, les objets sont toujours stockés dans l'espace unique des objets (voir partie sur le <a href="cm_memoire_donnees.html">modèle de données</a>),
		mais pour rendre le schéma plus lisible les objets sont montrés éparpillés autour du namespace.)</p>
<img alt="" src="img/cm_namespaces/constructeur.png"/>
<h3 data-nb="8.9.4" id="Namespace des deux instances de MaClasse:">Namespace des deux instances de MaClasse:</h3>
<p>Les namespaces des objets sont un peu spéciaux, car on n'exécute jamais du code dans le "contexte" d'un objet, mais dans des méthodes, où on y fait
		référence toujours par le paramètre "self", comme dans le constructeur tel qu'illustré dans le schéma plus haut. C'est pour cette raison que les autres
		variables n'apparaissent pas sur le schéma ci-dessous, car la notion de visibilité n'a pas vraiment de sens, seule la notion de nom DANS le namespace de
		chaque objet est pertinente. Mais conceptuellement on peut représenter les namespaces des deux instances "mon_objet_1" et "mon_objet_2" comme
		ci-dessous. </p>
<p>(Attention, les objets sont toujours stockés dans l'espace unique des objets (voir partie sur le <a href="cm_memoire_donnees.html">modèle de données</a>),
		mais pour rendre le schéma plus lisible les objets sont montrés éparpillés autour du namespace.)</p>
<img alt="" src="img/cm_namespaces/objets.png"/>
	
	<h2 data-nb="8.10" id="Bibliothèque standard de Python">Bibliothèque standard de Python</h2>
<p>De très nombreuses fonctionnalités de Python sont séparées dans des modules qu'il faut importer spécifiquement. Ces modules ne font pas partie du langage
		en lui-même, mais forment ce qu'on appelle la <em>bibliothèque standard</em>. Une implémentation de Python n'est pas obligée d'inclure cette
		bibliothèque standard. Vous pouvez voir la liste exhaustive de <a href="https://docs.python.org/fr/3/library/index.html">tous les modules standards</a>
		dans la documentation officielle.</p>
<p>Il existe un module particulier nommé <code>builtins</code> (qui signifie "intégrés" en anglais) qui est importé automatiquement d'une façon qui lui est
		particulière. Il contient les fonctions qu'on a utilisées depuis toujours, comme <code>print()</code>, <code>input()</code> etc... Pour obtenir une
		référence vers <code>builtins</code> (objet de type <code>module</code>) il faut quand même l'importer explicitement avec <code class="language-python">import
			builtins</code>. Une implémentation de Python DOIT inclure ce module, car il contient des éléments fondamentaux du langage. Vous avez dans la
		documentation officielle la liste complète de toutes les <a href="https://docs.python.org/fr/3/library/functions.html">fonctions</a>, tous les <a href="https://docs.python.org/fr/3/library/stdtypes.html">types</a>, toutes les <a href="https://docs.python.org/fr/3/library/constants.html">constantes</a>
		et <a href="https://docs.python.org/fr/3/library/exceptions.html">exceptions</a> qui existent dans le module <code>builtins</code>.</p>





		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
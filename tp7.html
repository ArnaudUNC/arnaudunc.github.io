<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>✏️ TP 7 - Prog. objets niv.5 ✔️ | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_spec_impl_versions.html">
				Spécification, implémentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_methodes_exec.html">
				Façons d'exécuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_memoire_donnees.html">
				Mémoire et modèle de données
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_sequences.html">
				Les séquences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancées sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramètres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_compr_listes.html">
				Compréhension de listes et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td1.html">
				✍️ TD 1 - Calculatrice niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp1.html">
				✏️ TP 1 - Calculatrice niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td2.html">
				✍️ TD 2 - Prog. objets niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp2.html">
				✏️ TP 2 - Calculatrice niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp3.html">
				✏️ TP 3 - Calculatrice niv.4 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td3.html">
				✍️ TD 3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp4.html">
				✏️ TP 4 - Prog. objets niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp5.html">
				✏️ TP 5 - Prog. objets niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cc1_2022.html">
				📝 Contrôle continu 1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp6.html">
				✏️ TP 6 - Prog. objets niv.4 ✔️
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp7.html">
				✏️ TP 7 - Prog. objets niv.5 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_1.html">
				✏️ TP 8 - Boutique niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_2.html">
				✏️ TP 9 - Boutique niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_pendu_1.html">
				✏️ TP 10 - Jeu du pendu niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_pendu_2.html">
				✏️ TP 11 - Jeu du pendu niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cc2_2022_taches.html">
				📝 Contrôle continu 2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_pendu_3.html">
				✏️ TP 12 - Jeu du pendu niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="cc3_2022_etudiants.html">
				📝 Contrôle continu 3 ✔️
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	<h1 data-nb="27" id="✏️ TP 7 - Prog. objets niv.5 ✔️">✏️ TP 7 - Prog. objets niv.5 ✔️</h1>
	

	<p>Ce TP est la suite directe du TP 6.</p>

	
	<div class="exercice">
<h2 data-nb="27.1" id="Question 1">Question 1</h2>
<p>Il est temps d'ajouter quelques ennemis sur notre Terrain. Ils ne font rien, et ne bloquent pas le joueur pour le moment, mais ils sont affichés.</p>
<video controls="" preload="none" src="img/tp6/q4.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Le Terrain et le Jeu doivent avoir chacun leur propre liste des Personnages ennemis: le Terrain pour pouvoir les dessiner, et le Jeu pour les
				faire saluer et ainsi afficher leurs détails (nom, vie etc...). Donc ajouter les attributs là il faut. Les ennemis doivent être ajoutés <em>après</em>
				l'instanciation du Jeu et du Terrain. Si on ajoute un ennemi au Terrain, attention à l'ajouter également au Jeu, pour que le dessin du terrain
				<em>et</em> les salutations correspondent bien.
			</li>
<li>La création d'une méthode <code>avoir_ennemi_a_position()</code> dans la classe Terrain devrait vous aider. Elle prend en paramètres (en plus de
				<code>self</code>) le x et y d'une case sur laquelle vous souhaitez savoir si un ennemi s'y trouve, et la méthode renvoie le premier ennemi sur
				la case en question s'il y en a un ou plusieurs, <code>None</code> sinon. Elle sera utile pour dessiner le Terrain, et dans la classe Personnage
				plus tard.
			</li>
<li>Pour vérifier que ça fonctionne: ajouter 2 ennemis au terrain, chacun avec un nom et un symbole différent pour leur affichage sur le terrain,
				vous les voyez dans le Terrain, vous voyez leur salutation à chacun, et le joueur peut passer à travers.
			</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os

					# ↓ Aucun changement dans cette classe pour cette question
					class Personnage:
						def __init__(self, nom_initial, pv_max, caractère_apparence, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractère_apparence = caractère_apparence
							self.terrain = terrain

						def déplacer(self, déplacement_x, déplacement_y):
							nouveau_x = self.position[0] + déplacement_x
							nouveau_y = self.position[1] + déplacement_y
							try:
								aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
							except IndexError:
								return
							if not aucun_obstacle:
								return
							if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
								self.position[0] = nouveau_x
							if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
								self.position[1] = nouveau_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins négatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soigné de", soins_effectifs, "points")

						def blesser(self, points_de_dégâts):
							if points_de_dégâts &gt; 0:
								vie_avant_dégâts = self.points_de_vie
								self.points_de_vie -= points_de_dégâts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dégâts, "dégâts")
								else:
									print(self.nom, "subit", points_de_dégâts, "dégâts")
							else:
								print("Dégâts négatifs ou zéro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							# ↓ Nouvel attribut
							self.ennemis = []
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						# ↓ On a rajouté cette méthode
						# pour pouvoir facilement avoir un ennemi dans une case du Terrain,
						# s'il y en a un, None sinon.
						def avoir_ennemi_a_position(self, x, y):
							for ennemi in self.ennemis:
								if ennemi.position[0] == x and ennemi.position[1] == y:
									return ennemi

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									# ↓ On retrouve l'ennemi (s'il y en a un) dans la case en cours,
									# pour pouvoir le dessiner.
									# C'est ici qu'on décide de qui l'emporte en priorité pour être dessiné,
									# si plusieurs entités se trouvent dans la même case: joueur, mur ou ennemi.
									ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
									if self.perso.position == [i, j]:
										ligne += self.perso.caractère_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "██"
									elif ennemi_dans_case:
										ligne += ennemi_dans_case.caractère_apparence + " "
									else:
										ligne += "· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso):
							self.terrain = terrain
							self.perso = perso
							# ↓ Nouvel attribut
							self.ennemis = []

						def démarrer(self):
							action_utilisateur = ""
							while action_utilisateur != "qq":
								os.system("cls")
								self.terrain.dessiner()
								self.perso.saluer()
								# ↓ Les ennemis doivent saluer aussi
								# pour qu'on puisse afficher leurs informations (vie, position etc).
								for ennemi in self.ennemis:
									ennemi.saluer()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.déplacer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.déplacer(1, 0)
								elif action_utilisateur == "z":
									self.perso.déplacer(0, -1)
								elif action_utilisateur == "s":
									self.perso.déplacer(0, 1)


					terrain = Terrain(10, 10)
					perso1 = Personnage("Toto", 100, "@", 5, 3, terrain)
					ennemi_1 = Personnage("Monstre 1", 40, "1", 6, 8, terrain)
					ennemi_2 = Personnage("Monstre 2", 60, "2", 7, 1, terrain)
					terrain.perso = perso1
					# ↓ On ajoute 2 ennemis sur le terrain
					terrain.ennemis.append(ennemi_1)
					terrain.ennemis.append(ennemi_2)
					# mur haut gauche
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					# pièce en bas
					terrain.cases[4][9] = 0
					terrain.cases[5][9] = 0
					terrain.cases[6][9] = 0
					terrain.cases[7][9] = 0
					terrain.cases[8][9] = 0

					terrain.cases[4][8] = 0
					terrain.cases[4][7] = 0
					terrain.cases[4][6] = 0

					terrain.cases[8][8] = 0
					terrain.cases[8][7] = 0
					terrain.cases[8][6] = 0

					terrain.cases[6][6] = 0
					terrain.cases[7][6] = 0

					terrain.cases[3][7] = 0
					terrain.cases[2][7] = 0
					jeu = Jeu(terrain, perso1)
					# ↓ On ajoute les mêmes 2 ennemis au jeu également
					jeu.ennemis.append(ennemi_1)
					jeu.ennemis.append(ennemi_2)
					jeu.démarrer()
				</code></pre>
</div>
		
	</div>

	
	<div class="exercice">
<h2 data-nb="27.2" id="Question 2">Question 2</h2>
<p>Désormais le joueur peut attaquer et tuer les ennemis en se déplaçant vers eux. Les dégâts sont affichés pendant une ou deux secondes. Le jeu
			s'arrête lorsque tous les ennemis sont vaincus et un message de victoire est affiché. Si le joueur quitte avant, le message de game over est
			affiché.</p>
<video controls="" preload="none" src="img/tp6/q5.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Faites en sorte que les ennemis bloquent le joueur. Cela peut être fait dans la méthode de déplacement dans la classe Personnage, et vous pouvez
				aussi utiliser la méthode <code>avoir_ennemi_a_position()</code> de la classe Terrain pour facilement avoir l'ennemi (s'il y en a un) qui se
				trouve sur la case de destination du perso joueur quand celui-ci se déplace.
			</li>
<li>Le perso joueur attaque les ennemis vivants qui se trouve sur son chemin, mais ignore les morts.</li>
<li>L'affichage des dégâts est effacé à chaque tour (à cause de <code>os.system()</code>) et il est donc impossible de lire ce qui se passe (quel
				perso attaque qui). Pour corriger ça, utiliser la fonction <code>sleep()</code> du module <code>time</code>. Elle prend un paramètre: le nombre
				de secondes à attendre. Quand cette fonction est appelée, le programme se met en pause pour la durée demandée, puis reprend à la ligne suivante
				de l'appel de la fonction.
			</li>
<li>Les Personnages morts sont affichés différemment sur le Terrain par rapport à quand ils sont vivants, donc il vous faut un second caractère
				d'affichage pour chaque perso.
			</li>
<li>Afficher un message de victoire ou de game over à la fin de la partie, selon comment le jeu se termine. De plus, en cas de victoire, attention à
				bien afficher tout correctement pour le dernier affichage du Terrain: tous les ennemis sont bien affichés comme morts sur le Terrain et dans
				leur salutation.
			</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os
					# ↓ On importe aussi le module "time" désormais,
					# car on a besoin de sa fonction "sleep".
					import time

					class Personnage:
						# ↓ Ajout du paramètre char_mort: caractère qui représentera le Personnage quand il sera mort
						def __init__(self, nom_initial, pv_max, caractère_apparence, char_mort, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractère_apparence = caractère_apparence
							# ↓ Nouvelle attribut: caractère qui représentera le Personnage quand il sera mort
							self.char_mort = char_mort
							self.terrain = terrain

						def déplacer(self, déplacement_x, déplacement_y):
							nouveau_x = self.position[0] + déplacement_x
							nouveau_y = self.position[1] + déplacement_y
							try:
								aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
								# ↓ C'est ici quand vérifie les collisions avec les ennemis,
								# et qu'on attaque l'ennemi dans la case destination, s'il y en a un.
								ennemi_dans_destination = self.terrain.avoir_ennemi_a_position(nouveau_x, nouveau_y)
								if ennemi_dans_destination:
									# ↓ On attaque uniquement les ennemis vivants
									if ennemi_dans_destination.points_de_vie &gt; 0:
										aucun_obstacle = False
										self.attaquer(ennemi_dans_destination)
										# ↓ On met le programme en pause pendant 2 secondes,
										# pour permettre au joueur de lire les messages affichés
										# lors de l'attaque, car ils seront effacés à la prochaine
										# itération du Jeu, à cause de l'appel à os.system("clear").
										time.sleep(2)
							except IndexError:
								return
							if not aucun_obstacle:
								return
							if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
								self.position[0] = nouveau_x
							if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
								self.position[1] = nouveau_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins négatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soigné de", soins_effectifs, "points")

						def blesser(self, points_de_dégâts):
							if points_de_dégâts &gt; 0:
								vie_avant_dégâts = self.points_de_vie
								self.points_de_vie -= points_de_dégâts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dégâts, "dégâts")
								else:
									print(self.nom, "subit", points_de_dégâts, "dégâts")
							else:
								print("Dégâts négatifs ou zéro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							self.ennemis = []
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						def avoir_ennemi_a_position(self, x, y):
							for ennemi in self.ennemis:
								if ennemi.position[0] == x and ennemi.position[1] == y:
									return ennemi

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
									if self.perso.position == [i, j]:
										ligne += self.perso.caractère_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "██"
									elif ennemi_dans_case:
										if ennemi_dans_case.points_de_vie &gt; 0:
											ligne += ennemi_dans_case.caractère_apparence + " "
										else:
											ligne += ennemi_dans_case.char_mort + " "
									else:
										ligne += "· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso: Personnage):
							self.terrain = terrain
							self.perso = perso
							self.ennemis = []

						# ↓ On a ajouté cette méthode, car on a besoin d'afficher le jeu
						# a deux endroits différents dans la méthode "démarrer" ci-dessous.
						# Rappelez-vous: dès que du code similaire apparaît à au moins deux endroits
						# de votre programme, vous devez le mettre dans une fonction/méthode, et
						# appeler la fonction/méthode. La duplication de code est signe qu'il est
						# "mauvais": il vous apportera très vite complexité, bugs,
						# et difficultés à le modifier.
						def afficher_jeu(self):
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							for ennemi in self.ennemis:
								ennemi.saluer()

						def démarrer(self):
							action_utilisateur = ""
							# ↓ On continue le Jeu tant que le joueur le souhaite
							# ET qu'il y a encore au moins un ennemi en vie dans le Jeu,
							# car on souhaite que le Jeu s'arrête et on déclare la victoire
							# du joueur lorsque tous les ennemis sont morts.
							au_moins_un_ennemi_vivant = True
							while action_utilisateur != "qq" and au_moins_un_ennemi_vivant:
								self.afficher_jeu()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.déplacer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.déplacer(1, 0)
								elif action_utilisateur == "z":
									self.perso.déplacer(0, -1)
								elif action_utilisateur == "s":
									self.perso.déplacer(0, 1)

								# ↓ On vérifie qu'il y a encore un ennemi vivant dans le Jeu,
								# pour savoir si on continue le jeu ou pas à la prochaine itération.
								au_moins_un_ennemi_vivant = False
								for ennemi in self.ennemis:
									if ennemi.points_de_vie &gt; 0:
										au_moins_un_ennemi_vivant = True
										break
							# ↓ On affiche un message différent selon que le joueur a gagné,
							# ou quitté volontairement le jeu.
							self.afficher_jeu()
							if action_utilisateur == "qq":
								print("Vous fuyez la partie? Lâche!")
							else:
								print("Vous êtes victorieux, gloire à vous!")


					terrain = Terrain(10, 10)
					# ↓ On a rajouté les caractères d'affichage en cas de mort,
					# pour chaque Personnage, comme paramètre pour l'appel de leur constructeur.
					perso1 = Personnage("Toto", 100, "@", "@", 5, 1, terrain)
					ennemi_1 = Personnage("Monstre 1", 40, "1", "†", 6, 8, terrain)
					ennemi_2 = Personnage("Monstre 2", 60, "2", "X", 7, 1, terrain)
					terrain.perso = perso1
					terrain.ennemis.append(ennemi_1)
					terrain.ennemis.append(ennemi_2)
					# mur haut gauche
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					# pièce en bas
					terrain.cases[4][9] = 0
					terrain.cases[5][9] = 0
					terrain.cases[6][9] = 0
					terrain.cases[7][9] = 0
					terrain.cases[8][9] = 0

					terrain.cases[4][8] = 0
					terrain.cases[4][7] = 0
					terrain.cases[4][6] = 0

					terrain.cases[8][8] = 0
					terrain.cases[8][7] = 0
					terrain.cases[8][6] = 0

					terrain.cases[6][6] = 0
					terrain.cases[7][6] = 0

					terrain.cases[3][7] = 0
					terrain.cases[2][7] = 0
					jeu = Jeu(terrain, perso1)
					jeu.ennemis.append(ennemi_1)
					jeu.ennemis.append(ennemi_2)
					jeu.démarrer()
				</code></pre>
</div>
		
	</div>


		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>âœï¸ TP 7 - Prog. objets niv.5 âœ”ï¸ | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E ğŸ %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		ğŸ

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_spec_impl_versions.html">
				SpÃ©cification, implÃ©mentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_methodes_exec.html">
				FaÃ§ons d'exÃ©cuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_memoire_donnees.html">
				MÃ©moire et modÃ¨le de donnÃ©es
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_sequences.html">
				Les sÃ©quences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancÃ©es sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramÃ¨tres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_compr_listes.html">
				ComprÃ©hension de listes et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="td1.html">
				âœï¸ TD 1 - Calculatrice niv.1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp1.html">
				âœï¸ TP 1 - Calculatrice niv.2 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="td2.html">
				âœï¸ TD 2 - Prog. objets niv.1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp2.html">
				âœï¸ TP 2 - Calculatrice niv.3 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp3.html">
				âœï¸ TP 3 - Calculatrice niv.4 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="td3.html">
				âœï¸ TD 3 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp4.html">
				âœï¸ TP 4 - Prog. objets niv.2 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp5.html">
				âœï¸ TP 5 - Prog. objets niv.3 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="cc1_2022.html">
				ğŸ“ ContrÃ´le continu 1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜’</span-->
			<a href="tp6.html">
				âœï¸ TP 6 - Prog. objets niv.4 âœ”ï¸
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp7.html">
				âœï¸ TP 7 - Prog. objets niv.5 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp_boutique_1.html">
				âœï¸ TP 8 - Boutique niv.1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp_boutique_2.html">
				âœï¸ TP 9 - Boutique niv.2 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp_pendu_1.html">
				âœï¸ TP 10 - Jeu du pendu niv.1 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp_pendu_2.html">
				âœï¸ TP 11 - Jeu du pendu niv.2 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cc2_2022_taches.html">
				ğŸ“ ContrÃ´le continu 2 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="tp_pendu_3.html">
				âœï¸ TP 12 - Jeu du pendu niv.3 âœ”ï¸
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">â˜</span-->
			<a href="cc3_2022_etudiants.html">
				ğŸ“ ContrÃ´le continu 3 âœ”ï¸
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	<h1 data-nb="27" id="âœï¸ TP 7 - Prog. objets niv.5 âœ”ï¸">âœï¸ TP 7 - Prog. objets niv.5 âœ”ï¸</h1>
	

	<p>Ce TP est la suite directe du TP 6.</p>

	
	<div class="exercice">
<h2 data-nb="27.1" id="Question 1">Question 1</h2>
<p>Il est temps d'ajouter quelques ennemis sur notre Terrain. Ils ne font rien, et ne bloquent pas le joueur pour le moment, mais ils sont affichÃ©s.</p>
<video controls="" preload="none" src="img/tp6/q4.mp4"></video>
<p>Faites selon la faÃ§on qui vous convient, ou utilisez la faÃ§on ci-dessous:</p>
<ol>
<li>Le Terrain et le Jeu doivent avoir chacun leur propre liste des Personnages ennemis: le Terrain pour pouvoir les dessiner, et le Jeu pour les
				faire saluer et ainsi afficher leurs dÃ©tails (nom, vie etc...). Donc ajouter les attributs lÃ  il faut. Les ennemis doivent Ãªtre ajoutÃ©s <em>aprÃ¨s</em>
				l'instanciation du Jeu et du Terrain. Si on ajoute un ennemi au Terrain, attention Ã  l'ajouter Ã©galement au Jeu, pour que le dessin du terrain
				<em>et</em> les salutations correspondent bien.
			</li>
<li>La crÃ©ation d'une mÃ©thode <code>avoir_ennemi_a_position()</code> dans la classe Terrain devrait vous aider. Elle prend en paramÃ¨tres (en plus de
				<code>self</code>) le x et y d'une case sur laquelle vous souhaitez savoir si un ennemi s'y trouve, et la mÃ©thode renvoie le premier ennemi sur
				la case en question s'il y en a un ou plusieurs, <code>None</code> sinon. Elle sera utile pour dessiner le Terrain, et dans la classe Personnage
				plus tard.
			</li>
<li>Pour vÃ©rifier que Ã§a fonctionne: ajouter 2 ennemis au terrain, chacun avec un nom et un symbole diffÃ©rent pour leur affichage sur le terrain,
				vous les voyez dans le Terrain, vous voyez leur salutation Ã  chacun, et le joueur peut passer Ã  travers.
			</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os

					# â†“ Aucun changement dans cette classe pour cette question
					class Personnage:
						def __init__(self, nom_initial, pv_max, caractÃ¨re_apparence, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractÃ¨re_apparence = caractÃ¨re_apparence
							self.terrain = terrain

						def dÃ©placer(self, dÃ©placement_x, dÃ©placement_y):
							nouveau_x = self.position[0] + dÃ©placement_x
							nouveau_y = self.position[1] + dÃ©placement_y
							try:
								aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
							except IndexError:
								return
							if not aucun_obstacle:
								return
							if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
								self.position[0] = nouveau_x
							if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
								self.position[1] = nouveau_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins nÃ©gatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soignÃ© de", soins_effectifs, "points")

						def blesser(self, points_de_dÃ©gÃ¢ts):
							if points_de_dÃ©gÃ¢ts &gt; 0:
								vie_avant_dÃ©gÃ¢ts = self.points_de_vie
								self.points_de_vie -= points_de_dÃ©gÃ¢ts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dÃ©gÃ¢ts, "dÃ©gÃ¢ts")
								else:
									print(self.nom, "subit", points_de_dÃ©gÃ¢ts, "dÃ©gÃ¢ts")
							else:
								print("DÃ©gÃ¢ts nÃ©gatifs ou zÃ©ro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							# â†“ Nouvel attribut
							self.ennemis = []
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						# â†“ On a rajoutÃ© cette mÃ©thode
						# pour pouvoir facilement avoir un ennemi dans une case du Terrain,
						# s'il y en a un, None sinon.
						def avoir_ennemi_a_position(self, x, y):
							for ennemi in self.ennemis:
								if ennemi.position[0] == x and ennemi.position[1] == y:
									return ennemi

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									# â†“ On retrouve l'ennemi (s'il y en a un) dans la case en cours,
									# pour pouvoir le dessiner.
									# C'est ici qu'on dÃ©cide de qui l'emporte en prioritÃ© pour Ãªtre dessinÃ©,
									# si plusieurs entitÃ©s se trouvent dans la mÃªme case: joueur, mur ou ennemi.
									ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
									if self.perso.position == [i, j]:
										ligne += self.perso.caractÃ¨re_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "â–ˆâ–ˆ"
									elif ennemi_dans_case:
										ligne += ennemi_dans_case.caractÃ¨re_apparence + " "
									else:
										ligne += "Â· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso):
							self.terrain = terrain
							self.perso = perso
							# â†“ Nouvel attribut
							self.ennemis = []

						def dÃ©marrer(self):
							action_utilisateur = ""
							while action_utilisateur != "qq":
								os.system("cls")
								self.terrain.dessiner()
								self.perso.saluer()
								# â†“ Les ennemis doivent saluer aussi
								# pour qu'on puisse afficher leurs informations (vie, position etc).
								for ennemi in self.ennemis:
									ennemi.saluer()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.dÃ©placer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.dÃ©placer(1, 0)
								elif action_utilisateur == "z":
									self.perso.dÃ©placer(0, -1)
								elif action_utilisateur == "s":
									self.perso.dÃ©placer(0, 1)


					terrain = Terrain(10, 10)
					perso1 = Personnage("Toto", 100, "@", 5, 3, terrain)
					ennemi_1 = Personnage("Monstre 1", 40, "1", 6, 8, terrain)
					ennemi_2 = Personnage("Monstre 2", 60, "2", 7, 1, terrain)
					terrain.perso = perso1
					# â†“ On ajoute 2 ennemis sur le terrain
					terrain.ennemis.append(ennemi_1)
					terrain.ennemis.append(ennemi_2)
					# mur haut gauche
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					# piÃ¨ce en bas
					terrain.cases[4][9] = 0
					terrain.cases[5][9] = 0
					terrain.cases[6][9] = 0
					terrain.cases[7][9] = 0
					terrain.cases[8][9] = 0

					terrain.cases[4][8] = 0
					terrain.cases[4][7] = 0
					terrain.cases[4][6] = 0

					terrain.cases[8][8] = 0
					terrain.cases[8][7] = 0
					terrain.cases[8][6] = 0

					terrain.cases[6][6] = 0
					terrain.cases[7][6] = 0

					terrain.cases[3][7] = 0
					terrain.cases[2][7] = 0
					jeu = Jeu(terrain, perso1)
					# â†“ On ajoute les mÃªmes 2 ennemis au jeu Ã©galement
					jeu.ennemis.append(ennemi_1)
					jeu.ennemis.append(ennemi_2)
					jeu.dÃ©marrer()
				</code></pre>
</div>
		
	</div>

	
	<div class="exercice">
<h2 data-nb="27.2" id="Question 2">Question 2</h2>
<p>DÃ©sormais le joueur peut attaquer et tuer les ennemis en se dÃ©plaÃ§ant vers eux. Les dÃ©gÃ¢ts sont affichÃ©s pendant une ou deux secondes. Le jeu
			s'arrÃªte lorsque tous les ennemis sont vaincus et un message de victoire est affichÃ©. Si le joueur quitte avant, le message de game over est
			affichÃ©.</p>
<video controls="" preload="none" src="img/tp6/q5.mp4"></video>
<p>Faites selon la faÃ§on qui vous convient, ou utilisez la faÃ§on ci-dessous:</p>
<ol>
<li>Faites en sorte que les ennemis bloquent le joueur. Cela peut Ãªtre fait dans la mÃ©thode de dÃ©placement dans la classe Personnage, et vous pouvez
				aussi utiliser la mÃ©thode <code>avoir_ennemi_a_position()</code> de la classe Terrain pour facilement avoir l'ennemi (s'il y en a un) qui se
				trouve sur la case de destination du perso joueur quand celui-ci se dÃ©place.
			</li>
<li>Le perso joueur attaque les ennemis vivants qui se trouve sur son chemin, mais ignore les morts.</li>
<li>L'affichage des dÃ©gÃ¢ts est effacÃ© Ã  chaque tour (Ã  cause de <code>os.system()</code>) et il est donc impossible de lire ce qui se passe (quel
				perso attaque qui). Pour corriger Ã§a, utiliser la fonction <code>sleep()</code> du module <code>time</code>. Elle prend un paramÃ¨tre: le nombre
				de secondes Ã  attendre. Quand cette fonction est appelÃ©e, le programme se met en pause pour la durÃ©e demandÃ©e, puis reprend Ã  la ligne suivante
				de l'appel de la fonction.
			</li>
<li>Les Personnages morts sont affichÃ©s diffÃ©remment sur le Terrain par rapport Ã  quand ils sont vivants, donc il vous faut un second caractÃ¨re
				d'affichage pour chaque perso.
			</li>
<li>Afficher un message de victoire ou de game over Ã  la fin de la partie, selon comment le jeu se termine. De plus, en cas de victoire, attention Ã 
				bien afficher tout correctement pour le dernier affichage du Terrain: tous les ennemis sont bien affichÃ©s comme morts sur le Terrain et dans
				leur salutation.
			</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os
					# â†“ On importe aussi le module "time" dÃ©sormais,
					# car on a besoin de sa fonction "sleep".
					import time

					class Personnage:
						# â†“ Ajout du paramÃ¨tre char_mort: caractÃ¨re qui reprÃ©sentera le Personnage quand il sera mort
						def __init__(self, nom_initial, pv_max, caractÃ¨re_apparence, char_mort, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractÃ¨re_apparence = caractÃ¨re_apparence
							# â†“ Nouvelle attribut: caractÃ¨re qui reprÃ©sentera le Personnage quand il sera mort
							self.char_mort = char_mort
							self.terrain = terrain

						def dÃ©placer(self, dÃ©placement_x, dÃ©placement_y):
							nouveau_x = self.position[0] + dÃ©placement_x
							nouveau_y = self.position[1] + dÃ©placement_y
							try:
								aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
								# â†“ C'est ici quand vÃ©rifie les collisions avec les ennemis,
								# et qu'on attaque l'ennemi dans la case destination, s'il y en a un.
								ennemi_dans_destination = self.terrain.avoir_ennemi_a_position(nouveau_x, nouveau_y)
								if ennemi_dans_destination:
									# â†“ On attaque uniquement les ennemis vivants
									if ennemi_dans_destination.points_de_vie &gt; 0:
										aucun_obstacle = False
										self.attaquer(ennemi_dans_destination)
										# â†“ On met le programme en pause pendant 2 secondes,
										# pour permettre au joueur de lire les messages affichÃ©s
										# lors de l'attaque, car ils seront effacÃ©s Ã  la prochaine
										# itÃ©ration du Jeu, Ã  cause de l'appel Ã  os.system("clear").
										time.sleep(2)
							except IndexError:
								return
							if not aucun_obstacle:
								return
							if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
								self.position[0] = nouveau_x
							if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
								self.position[1] = nouveau_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins nÃ©gatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soignÃ© de", soins_effectifs, "points")

						def blesser(self, points_de_dÃ©gÃ¢ts):
							if points_de_dÃ©gÃ¢ts &gt; 0:
								vie_avant_dÃ©gÃ¢ts = self.points_de_vie
								self.points_de_vie -= points_de_dÃ©gÃ¢ts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dÃ©gÃ¢ts, "dÃ©gÃ¢ts")
								else:
									print(self.nom, "subit", points_de_dÃ©gÃ¢ts, "dÃ©gÃ¢ts")
							else:
								print("DÃ©gÃ¢ts nÃ©gatifs ou zÃ©ro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							self.ennemis = []
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						def avoir_ennemi_a_position(self, x, y):
							for ennemi in self.ennemis:
								if ennemi.position[0] == x and ennemi.position[1] == y:
									return ennemi

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
									if self.perso.position == [i, j]:
										ligne += self.perso.caractÃ¨re_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "â–ˆâ–ˆ"
									elif ennemi_dans_case:
										if ennemi_dans_case.points_de_vie &gt; 0:
											ligne += ennemi_dans_case.caractÃ¨re_apparence + " "
										else:
											ligne += ennemi_dans_case.char_mort + " "
									else:
										ligne += "Â· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso: Personnage):
							self.terrain = terrain
							self.perso = perso
							self.ennemis = []

						# â†“ On a ajoutÃ© cette mÃ©thode, car on a besoin d'afficher le jeu
						# a deux endroits diffÃ©rents dans la mÃ©thode "dÃ©marrer" ci-dessous.
						# Rappelez-vous: dÃ¨s que du code similaire apparaÃ®t Ã  au moins deux endroits
						# de votre programme, vous devez le mettre dans une fonction/mÃ©thode, et
						# appeler la fonction/mÃ©thode. La duplication de code est signe qu'il est
						# "mauvais": il vous apportera trÃ¨s vite complexitÃ©, bugs,
						# et difficultÃ©s Ã  le modifier.
						def afficher_jeu(self):
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							for ennemi in self.ennemis:
								ennemi.saluer()

						def dÃ©marrer(self):
							action_utilisateur = ""
							# â†“ On continue le Jeu tant que le joueur le souhaite
							# ET qu'il y a encore au moins un ennemi en vie dans le Jeu,
							# car on souhaite que le Jeu s'arrÃªte et on dÃ©clare la victoire
							# du joueur lorsque tous les ennemis sont morts.
							au_moins_un_ennemi_vivant = True
							while action_utilisateur != "qq" and au_moins_un_ennemi_vivant:
								self.afficher_jeu()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.dÃ©placer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.dÃ©placer(1, 0)
								elif action_utilisateur == "z":
									self.perso.dÃ©placer(0, -1)
								elif action_utilisateur == "s":
									self.perso.dÃ©placer(0, 1)

								# â†“ On vÃ©rifie qu'il y a encore un ennemi vivant dans le Jeu,
								# pour savoir si on continue le jeu ou pas Ã  la prochaine itÃ©ration.
								au_moins_un_ennemi_vivant = False
								for ennemi in self.ennemis:
									if ennemi.points_de_vie &gt; 0:
										au_moins_un_ennemi_vivant = True
										break
							# â†“ On affiche un message diffÃ©rent selon que le joueur a gagnÃ©,
							# ou quittÃ© volontairement le jeu.
							self.afficher_jeu()
							if action_utilisateur == "qq":
								print("Vous fuyez la partie? LÃ¢che!")
							else:
								print("Vous Ãªtes victorieux, gloire Ã  vous!")


					terrain = Terrain(10, 10)
					# â†“ On a rajoutÃ© les caractÃ¨res d'affichage en cas de mort,
					# pour chaque Personnage, comme paramÃ¨tre pour l'appel de leur constructeur.
					perso1 = Personnage("Toto", 100, "@", "@", 5, 1, terrain)
					ennemi_1 = Personnage("Monstre 1", 40, "1", "â€ ", 6, 8, terrain)
					ennemi_2 = Personnage("Monstre 2", 60, "2", "X", 7, 1, terrain)
					terrain.perso = perso1
					terrain.ennemis.append(ennemi_1)
					terrain.ennemis.append(ennemi_2)
					# mur haut gauche
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					# piÃ¨ce en bas
					terrain.cases[4][9] = 0
					terrain.cases[5][9] = 0
					terrain.cases[6][9] = 0
					terrain.cases[7][9] = 0
					terrain.cases[8][9] = 0

					terrain.cases[4][8] = 0
					terrain.cases[4][7] = 0
					terrain.cases[4][6] = 0

					terrain.cases[8][8] = 0
					terrain.cases[8][7] = 0
					terrain.cases[8][6] = 0

					terrain.cases[6][6] = 0
					terrain.cases[7][6] = 0

					terrain.cases[3][7] = 0
					terrain.cases[2][7] = 0
					jeu = Jeu(terrain, perso1)
					jeu.ennemis.append(ennemi_1)
					jeu.ennemis.append(ennemi_2)
					jeu.dÃ©marrer()
				</code></pre>
</div>
		
	</div>


		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E ğŸ %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la premiÃ¨re ligne des <pre><code> qui est considÃ©rÃ©e toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un Ã©lÃ©ment dÃ©truit tous ses Ã©lÃ©ments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un Ã©lÃ©ment texte
	});

	// On ajoute un <br> avant et aprÃ¨s chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.notÃ©');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>â†“ Affichage dans la console (ou dans le shell, selon oÃ¹ vous lancez l'exÃ©cution)<mall>`;
		p.classList.add("lÃ©gende_placÃ©e_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_Ã _cliquer">ğŸ“ Afficher / cacher correction âœ“</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
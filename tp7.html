<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>✏️ TP 7 - Prog. objets niv.5 ✔️ | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<link rel="icon" href="img/favicon.svg">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="hsl(200,50%, 50%)" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75">
		Algo et prog 2
	</text>
	<text x="50" y="90">
		en Python
	</text>
</svg>

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="index.html#Introduction">
					Introduction
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="groupes.html#Groupes de TD / TP">
					Groupes de TD / TP
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="cm1.html#📖 Cours 1: rappels">
					📖 Cours 1: rappels
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="td1.html#✏️ TD 1 - Calculatrice niv.1 ✔️">
					✏️ TD 1 - Calculatrice niv.1 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp1.html#✏️ TP 1 - Calculatrice niv.2 ✔️">
					✏️ TP 1 - Calculatrice niv.2 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp2.html#✏️ TP 2 - Calculatrice niv.3 ✔️">
					✏️ TP 2 - Calculatrice niv.3 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp3.html#✏️ TP 3 - Calculatrice niv.4 ✔️">
					✏️ TP 3 - Calculatrice niv.4 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="cm2.html#📖 Cours 2: Programmation orientée objets">
					📖 Cours 2: Programmation orientée objets
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="td2.html#✏️ TD 2 - Prog. objets niv.1 ✔️">
					✏️ TD 2 - Prog. objets niv.1 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp4.html#✏️ TP 4 - Prog. objets niv.2 ✔️">
					✏️ TP 4 - Prog. objets niv.2 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp5.html#✏️ TP 5 - Prog. objets niv.3 ✔️">
					✏️ TP 5 - Prog. objets niv.3 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp6.html#✏️ TP 6 - Prog. objets niv.4 ✔️">
					✏️ TP 6 - Prog. objets niv.4 ✔️
				</a>
			</div>
	

	
			<div class="page_actuelle h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="#✏️ TP 7 - Prog. objets niv.5 ✔️">
					✏️ TP 7 - Prog. objets niv.5 ✔️
				</a>
			</div>
			<div class="page_actuelle h h2">
				<!--span class="ballot_box">☐</span-->
				<a href="#Question 1">
					Question 1
				</a>
			</div>
			<div class="page_actuelle h h2">
				<!--span class="ballot_box">☐</span-->
				<a href="#Question 2">
					Question 2
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cm3.html#📖 Cours 3: fonctionnalités de Python">
					📖 Cours 3: fonctionnalités de Python
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="td3.html#✏️ TD 3 ✔️">
					✏️ TD 3 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cm4.html#📖 Cours 4: rappels et compléments">
					📖 Cours 4: rappels et compléments
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="tp8.html#✏️ TP 8 ✔️">
					✏️ TP 8 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="tp9.html#✏️ TP 9 - Jeu du pendu niv.1">
					✏️ TP 9 - Jeu du pendu niv.1
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="exos_notes.html#📝 Exercices notés">
					📝 Exercices notés
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cc1_2021.html#📝 Contrôle continu 1">
					📝 Contrôle continu 1
				</a>
			</div>
	

	</div>
	<div id="contenu">
		

		<div class="nav_arrows">
		<div style="display: flex; flex-direction: row; justify-content: space-between; padding: 1em 0em;">
				<span>
					
						<a href="tp6.html">← Page précédente</a>
					
				</span>
			
				<span style="padding: 0 .5em;">
						<a href="index.html">1ère page</a>
					</span>
			
			<span>
				
					<a href="cm3.html">Page suivante →</a>
				
				</span>
		</div>
		</div>
		<hr>

		
	<h1 data-nb="13" id="✏️ TP 7 - Prog. objets niv.5 ✔️">✏️ TP 7 - Prog. objets niv.5 ✔️</h1>
<p>Ce TP est la suite directe du TP 6.</p>
<div class="exercice">
<h2 data-nb="13.1" id="Question 1">Question 1</h2>
<p>Il est temps d'ajouter quelques ennemis sur notre Terrain. Ils ne font rien, et ne bloquent pas le joueur pour le moment, mais ils sont affichés.</p>
<video controls="" preload="none" src="img/tp6/q4.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Le Terrain et le Jeu doivent avoir chacun leur propre liste des Personnages ennemis: le Terrain pour pouvoir les dessiner, et le Jeu pour les
				faire saluer et ainsi afficher leurs détails (nom, vie etc...). Donc ajouter les attributs là il faut. Les ennemis doivent être ajoutés <em>après</em>
				l'instanciation du Jeu et du Terrain. Si on ajoute un ennemi au Terrain, attention à l'ajouter également au Jeu, pour que le dessin du terrain
				<em>et</em> les salutations correspondent bien.
			</li>
<li>La création d'une méthode <code>avoir_ennemi_a_position()</code> dans la classe Terrain devrait vous aider. Elle prend en paramètres (en plus de
				<code>self</code>) le x et y d'une case sur laquelle vous souhaitez savoir si un ennemi s'y trouve, et la méthode renvoie le premier ennemi sur
				la case en question s'il y en a un ou plusieurs, <code>None</code> sinon. Elle sera utile pour dessiner le Terrain, et dans la classe Personnage
				plus tard.
			</li>
<li>Pour vérifier que ça fonctionne: ajouter 2 ennemis au terrain, chacun avec un nom et un symbole différent pour leur affichage sur le terrain,
				vous les voyez dans le Terrain, vous voyez leur salutation à chacun, et le joueur peut passer à travers.
			</li>
</ol>
<div class="correction">
<pre class="line-numbers"><code class="language-python">
				import os

				# ↓ Aucun changement dans cette classe pour cette question
				class Personnage:
					def __init__(self, nom_initial, pv_max, char_apparence, x, y, terrain):
						self.nom = nom_initial
						self.points_de_vie = self.points_de_vie_max = pv_max
						self.position = [x, y]
						self.char_apparence = char_apparence
						self.terrain = terrain

					def déplacer(self, déplacement_x, déplacement_y):
						nouveau_x = self.position[0] + déplacement_x
						nouveau_y = self.position[1] + déplacement_y
						try:
							aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
						except IndexError:
							return
						if not aucun_obstacle:
							return
						if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
							self.position[0] = nouveau_x
						if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
							self.position[1] = nouveau_y

					def saluer(self):
						if self.points_de_vie &gt; 0:
							print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
								  + "/" + str(self.points_de_vie_max) + ". Position=(" \
								  + str(self.position[0]) + "," + str(self.position[1]) + ")")
						else:
							print(self.nom, "est mort")

					def soigner(self, points_de_soin):
						if self.points_de_vie &lt;= 0:
							print("Impossible de soigner un perso mort")
							return
						if points_de_soin &lt;= 0:
							print("Soins négatifs, impossible")
							return
						vie_avant_soins = self.points_de_vie
						soins_effectifs = points_de_soin
						self.points_de_vie += points_de_soin
						if self.points_de_vie &gt; self.points_de_vie_max:
							soins_effectifs = self.points_de_vie_max - vie_avant_soins
							self.points_de_vie = self.points_de_vie_max
						print(self.nom, "est soigné de", soins_effectifs, "points")

					def blesser(self, points_de_dégâts):
						if points_de_dégâts &gt; 0:
							vie_avant_dégâts = self.points_de_vie
							self.points_de_vie -= points_de_dégâts
							if self.points_de_vie &lt; 0:
								self.points_de_vie = 0
								print(self.nom, "subit", vie_avant_dégâts, "dégâts")
							else:
								print(self.nom, "subit", points_de_dégâts, "dégâts")
						else:
							print("Dégâts négatifs ou zéro interdits pour", self.nom)

					def attaquer(self, perso_cible):
						print(self.nom, "attaque", perso_cible.nom)
						perso_cible.blesser(25)


				class Terrain:
					def __init__(self, taille_x, taille_y):
						self.taille_x = taille_x
						self.taille_y = taille_y
						self.perso = None
						# ↓ Nouvel attribut
						self.ennemis = []
						self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

					# ↓ On a rajouté cette méthode
					# pour pouvoir facilement avoir un ennemi dans une case du Terrain,
					# s'il y en a un, None sinon.
					def avoir_ennemi_a_position(self, x, y):
						for ennemi in self.ennemis:
							if ennemi.position[0] == x and ennemi.position[1] == y:
								return ennemi

					def dessiner(self):
						for j in range(self.taille_y):
							ligne = ""
							for i in range(self.taille_x):
								# ↓ On retrouve l'ennemi (s'il y en a un) dans la case en cours,
								# pour pouvoir le dessiner.
								# C'est ici qu'on décide de qui l'emporte en priorité pour être dessiné,
								# si plusieurs entités se trouvent dans la même case: joueur, mur ou ennemi.
								ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
								if self.perso.position == [i, j]:
									ligne += self.perso.char_apparence + " "
								elif self.cases[i][j] == 0:
									ligne += "██"
								elif ennemi_dans_case:
									ligne += ennemi_dans_case.char_apparence + " "
								else:
									ligne += "· "
							print(ligne)


				class Jeu:
					def __init__(self, terrain, perso):
						self.terrain = terrain
						self.perso = perso
						# ↓ Nouvel attribut
						self.ennemis = []

					def démarrer(self):
						action_utilisateur = ""
						while action_utilisateur != "qq":
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							# ↓ Les ennemis doivent saluer aussi
							# pour qu'on puisse afficher leurs informations (vie, position etc).
							for ennemi in self.ennemis:
								ennemi.saluer()
							action_utilisateur = input("Action: ")
							if action_utilisateur == "q":
								self.perso.déplacer(-1, 0)
							elif action_utilisateur == "d":
								self.perso.déplacer(1, 0)
							elif action_utilisateur == "z":
								self.perso.déplacer(0, -1)
							elif action_utilisateur == "s":
								self.perso.déplacer(0, 1)


				terrain = Terrain(10, 10)
				perso1 = Personnage("Toto", 100, "@", 5, 3, terrain)
				ennemi_1 = Personnage("Monstre 1", 40, "1", 6, 8, terrain)
				ennemi_2 = Personnage("Monstre 2", 60, "2", 7, 1, terrain)
				terrain.perso = perso1
				# ↓ On ajoute 2 ennemis sur le terrain
				terrain.ennemis.append(ennemi_1)
				terrain.ennemis.append(ennemi_2)
				# mur haut gauche
				terrain.cases[0][0] = 0
				terrain.cases[1][0] = 0
				terrain.cases[2][0] = 0
				terrain.cases[2][1] = 0
				terrain.cases[2][2] = 0
				terrain.cases[2][3] = 0
				terrain.cases[3][3] = 0
				# pièce en bas
				terrain.cases[4][9] = 0
				terrain.cases[5][9] = 0
				terrain.cases[6][9] = 0
				terrain.cases[7][9] = 0
				terrain.cases[8][9] = 0

				terrain.cases[4][8] = 0
				terrain.cases[4][7] = 0
				terrain.cases[4][6] = 0

				terrain.cases[8][8] = 0
				terrain.cases[8][7] = 0
				terrain.cases[8][6] = 0

				terrain.cases[6][6] = 0
				terrain.cases[7][6] = 0

				terrain.cases[3][7] = 0
				terrain.cases[2][7] = 0
				jeu = Jeu(terrain, perso1)
				# ↓ On ajoute les mêmes 2 ennemis au jeu également
				jeu.ennemis.append(ennemi_1)
				jeu.ennemis.append(ennemi_2)
				jeu.démarrer()
			</code></pre>
</div>
</div>
<div class="exercice">
<h2 data-nb="13.2" id="Question 2">Question 2</h2>
<p>Désormais le joueur peut attaquer et tuer les ennemis en se déplaçant vers eux. Les dégâts sont affichés pendant une ou deux secondes. Le jeu
			s'arrête lorsque tous les ennemis sont vaincus et un message de victoire est affiché. Si le joueur quitte avant, le message de game over est
			affiché.</p>
<video controls="" preload="none" src="img/tp6/q5.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Faites en sorte que les ennemis bloquent le joueur. Cela peut être fait dans la méthode de déplacement dans la classe Personnage, et vous pouvez
				aussi utiliser la méthode <code>avoir_ennemi_a_position()</code> de la classe Terrain pour facilement avoir l'ennemi (s'il y en a un) qui se
				trouve sur la case de destination du perso joueur quand celui-ci se déplace.
			</li>
<li>Le perso joueur attaque les ennemis vivants qui se trouve sur son chemin, mais ignore les morts.</li>
<li>L'affichage des dégâts est effacé à chaque tour (à cause de <code>os.system()</code>) et il est donc impossible de lire ce qui se passe (quel
				perso attaque qui). Pour corriger ça, utiliser la fonction <code>sleep()</code> du module <code>time</code>. Elle prend un paramètre: le nombre
				de secondes à attendre. Quand cette fonction est appelée, le programme se met en pause pour la durée demandée, puis reprend à la ligne suivante
				de l'appel de la fonction.
			</li>
<li>Les Personnages morts sont affichés différemment sur le Terrain par rapport à quand ils sont vivants, donc il vous faut un second caractère
				d'affichage pour chaque perso.
			</li>
<li>Afficher un message de victoire ou de game over à la fin de la partie, selon comment le jeu se termine. De plus, en cas de victoire, attention à
				bien afficher tout correctement pour le dernier affichage du Terrain: tous les ennemis sont bien affichés comme morts sur le Terrain et dans
				leur salutation.
			</li>
</ol>
<div class="correction">
<pre class="line-numbers"><code class="language-python">
				import os
				# ↓ On importe aussi le module "time" désormais,
				# car on a besoin de sa fonction "sleep".
				import time

				class Personnage:
					# ↓ Ajout du paramètre char_mort: caractère qui représentera le Personnage quand il sera mort
					def __init__(self, nom_initial, pv_max, char_apparence, char_mort, x, y, terrain):
						self.nom = nom_initial
						self.points_de_vie = self.points_de_vie_max = pv_max
						self.position = [x, y]
						self.char_apparence = char_apparence
						# ↓ Nouvelle attribut: caractère qui représentera le Personnage quand il sera mort
						self.char_mort = char_mort
						self.terrain = terrain

					def déplacer(self, déplacement_x, déplacement_y):
						nouveau_x = self.position[0] + déplacement_x
						nouveau_y = self.position[1] + déplacement_y
						try:
							aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
							# ↓ C'est ici quand vérifie les collisions avec les ennemis,
							# et qu'on attaque l'ennemi dans la case destination, s'il y en a un.
							ennemi_dans_destination = self.terrain.avoir_ennemi_a_position(nouveau_x, nouveau_y)
							if ennemi_dans_destination:
								# ↓ On attaque uniquement les ennemis vivants
								if ennemi_dans_destination.points_de_vie &gt; 0:
									aucun_obstacle = False
									self.attaquer(ennemi_dans_destination)
									# ↓ On met le programme en pause pendant 2 secondes,
									# pour permettre au joueur de lire les messages affichés
									# lors de l'attaque, car ils seront effacés à la prochaine
									# itération du Jeu, à cause de l'appel à os.system("clear").
									time.sleep(2)
						except IndexError:
							return
						if not aucun_obstacle:
							return
						if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
							self.position[0] = nouveau_x
						if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
							self.position[1] = nouveau_y

					def saluer(self):
						if self.points_de_vie &gt; 0:
							print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
								  + "/" + str(self.points_de_vie_max) + ". Position=(" \
								  + str(self.position[0]) + "," + str(self.position[1]) + ")")
						else:
							print(self.nom, "est mort")

					def soigner(self, points_de_soin):
						if self.points_de_vie &lt;= 0:
							print("Impossible de soigner un perso mort")
							return
						if points_de_soin &lt;= 0:
							print("Soins négatifs, impossible")
							return
						vie_avant_soins = self.points_de_vie
						soins_effectifs = points_de_soin
						self.points_de_vie += points_de_soin
						if self.points_de_vie &gt; self.points_de_vie_max:
							soins_effectifs = self.points_de_vie_max - vie_avant_soins
							self.points_de_vie = self.points_de_vie_max
						print(self.nom, "est soigné de", soins_effectifs, "points")

					def blesser(self, points_de_dégâts):
						if points_de_dégâts &gt; 0:
							vie_avant_dégâts = self.points_de_vie
							self.points_de_vie -= points_de_dégâts
							if self.points_de_vie &lt; 0:
								self.points_de_vie = 0
								print(self.nom, "subit", vie_avant_dégâts, "dégâts")
							else:
								print(self.nom, "subit", points_de_dégâts, "dégâts")
						else:
							print("Dégâts négatifs ou zéro interdits pour", self.nom)

					def attaquer(self, perso_cible):
						print(self.nom, "attaque", perso_cible.nom)
						perso_cible.blesser(25)


				class Terrain:
					def __init__(self, taille_x, taille_y):
						self.taille_x = taille_x
						self.taille_y = taille_y
						self.perso = None
						self.ennemis = []
						self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

					def avoir_ennemi_a_position(self, x, y):
						for ennemi in self.ennemis:
							if ennemi.position[0] == x and ennemi.position[1] == y:
								return ennemi

					def dessiner(self):
						for j in range(self.taille_y):
							ligne = ""
							for i in range(self.taille_x):
								ennemi_dans_case = self.avoir_ennemi_a_position(i, j)
								if self.perso.position == [i, j]:
									ligne += self.perso.char_apparence + " "
								elif self.cases[i][j] == 0:
									ligne += "██"
								elif ennemi_dans_case:
									if ennemi_dans_case.points_de_vie &gt; 0:
										ligne += ennemi_dans_case.char_apparence + " "
									else:
										ligne += ennemi_dans_case.char_mort + " "
								else:
									ligne += "· "
							print(ligne)


				class Jeu:
					def __init__(self, terrain, perso: Personnage):
						self.terrain = terrain
						self.perso = perso
						self.ennemis = []

					# ↓ On a ajouté cette méthode, car on a besoin d'afficher le jeu
					# a deux endroits différents dans la méthode "démarrer" ci-dessous.
					# Rappelez-vous: dès que du code similaire apparaît à au moins deux endroits
					# de votre programme, vous devez le mettre dans une fonction/méthode, et
					# appeler la fonction/méthode. La duplication de code est signe qu'il est
					# "mauvais": il vous apportera très vite complexité, bugs,
					# et difficultés à le modifier.
					def afficher_jeu(self):
						os.system("cls")
						self.terrain.dessiner()
						self.perso.saluer()
						for ennemi in self.ennemis:
							ennemi.saluer()

					def démarrer(self):
						action_utilisateur = ""
						# ↓ On continue le Jeu tant que le joueur le souhaite
						# ET qu'il y a encore au moins un ennemi en vie dans le Jeu,
						# car on souhaite que le Jeu s'arrête et on déclare la victoire
						# du joueur lorsque tous les ennemis sont morts.
						au_moins_un_ennemi_vivant = True
						while action_utilisateur != "qq" and au_moins_un_ennemi_vivant:
							self.afficher_jeu()
							action_utilisateur = input("Action: ")
							if action_utilisateur == "q":
								self.perso.déplacer(-1, 0)
							elif action_utilisateur == "d":
								self.perso.déplacer(1, 0)
							elif action_utilisateur == "z":
								self.perso.déplacer(0, -1)
							elif action_utilisateur == "s":
								self.perso.déplacer(0, 1)

							# ↓ On vérifie qu'il y a encore un ennemi vivant dans le Jeu,
							# pour savoir si on continue le jeu ou pas à la prochaine itération.
							au_moins_un_ennemi_vivant = False
							for ennemi in self.ennemis:
								if ennemi.points_de_vie &gt; 0:
									au_moins_un_ennemi_vivant = True
									break
						# ↓ On affiche un message différent selon que le joueur a gagné,
						# ou quitté volontairement le jeu.
						self.afficher_jeu()
						if action_utilisateur == "qq":
							print("Vous fuyez la partie? Lâche!")
						else:
							print("Vous êtes victorieux, gloire à vous!")


				terrain = Terrain(10, 10)
				# ↓ On a rajouté les caractères d'affichage en cas de mort,
				# pour chaque Personnage, comme paramètre pour l'appel de leur constructeur.
				perso1 = Personnage("Toto", 100, "@", "@", 5, 1, terrain)
				ennemi_1 = Personnage("Monstre 1", 40, "1", "†", 6, 8, terrain)
				ennemi_2 = Personnage("Monstre 2", 60, "2", "X", 7, 1, terrain)
				terrain.perso = perso1
				terrain.ennemis.append(ennemi_1)
				terrain.ennemis.append(ennemi_2)
				# mur haut gauche
				terrain.cases[0][0] = 0
				terrain.cases[1][0] = 0
				terrain.cases[2][0] = 0
				terrain.cases[2][1] = 0
				terrain.cases[2][2] = 0
				terrain.cases[2][3] = 0
				terrain.cases[3][3] = 0
				# pièce en bas
				terrain.cases[4][9] = 0
				terrain.cases[5][9] = 0
				terrain.cases[6][9] = 0
				terrain.cases[7][9] = 0
				terrain.cases[8][9] = 0

				terrain.cases[4][8] = 0
				terrain.cases[4][7] = 0
				terrain.cases[4][6] = 0

				terrain.cases[8][8] = 0
				terrain.cases[8][7] = 0
				terrain.cases[8][6] = 0

				terrain.cases[6][6] = 0
				terrain.cases[7][6] = 0

				terrain.cases[3][7] = 0
				terrain.cases[2][7] = 0
				jeu = Jeu(terrain, perso1)
				jeu.ennemis.append(ennemi_1)
				jeu.ennemis.append(ennemi_2)
				jeu.démarrer()
			</code></pre>
</div>
</div>



		<div class="nav_arrows">
			<hr>
			
		<div style="display: flex; flex-direction: row; justify-content: space-between; padding: 1em 0em;">
				<span>
					
						<a href="tp6.html">← Page précédente</a>
					
				</span>
			
				<span style="padding: 0 .5em;">
						<a href="index.html">1ère page</a>
					</span>
			
			<span>
				
					<a href="cm3.html">Page suivante →</a>
				
				</span>
		</div>
		
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
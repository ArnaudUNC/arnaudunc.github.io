<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>✏️ TP 6 - Prog. objets niv.4 ✔️ | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_spec_impl_versions.html">
				Spécification, implémentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_methodes_exec.html">
				Façons d'exécuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_memoire_donnees.html">
				Mémoire et modèle de données
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_sequences.html">
				Les séquences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancées sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramètres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_compr_listes.html">
				Compréhension de listes et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td1.html">
				✍️ TD 1 - Calculatrice niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp1.html">
				✏️ TP 1 - Calculatrice niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td2.html">
				✍️ TD 2 - Prog. objets niv.1 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp2.html">
				✏️ TP 2 - Calculatrice niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp3.html">
				✏️ TP 3 - Calculatrice niv.4 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td3.html">
				✍️ TD 3
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp4.html">
				✏️ TP 4 - Prog. objets niv.2 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="tp5.html">
				✏️ TP 5 - Prog. objets niv.3 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cc1_2022.html">
				📝 Contrôle continu 1
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp6.html">
				✏️ TP 6 - Prog. objets niv.4 ✔️
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp7.html">
				✏️ TP 7 - Prog. objets niv.5
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_1.html">
				✏️ TP 8 - Boutique niv.1
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp_boutique_2.html">
				✏️ TP 9 - Boutique niv.2
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	<h1 data-nb="26" id="✏️ TP 6 - Prog. objets niv.4 ✔️">✏️ TP 6 - Prog. objets niv.4 ✔️</h1>
	

	<p>Ce TP est la suite directe du TP 5.</p>

	
	<div class="exercice">
<h2 data-nb="26.1" id="Question 1">Question 1</h2>
<p>On veut qu'il soit impossible pour un Personnage de sortir du Terrain, il faut le restreindre dans l'aire de jeu.</p>
<video controls="" preload="none" src="img/tp6/q1.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>chaque Personnage aura besoin de savoir sur quel Terrain il se trouve, donc ajouter un attribut (par exemple <code>terrain</code>) dans le
				constructeur de Personnage. Le Terrain doit être spécifié au moment de la création du perso, donc ajouter également un paramètre au
				constructeur, et initialiser la valeur de l'attribut avec la valeur du paramètre.
			</li>
<li><p>Jusqu'à présent, le déplacement du Personnage se fait en modifiant sa position depuis la classe Jeu, mais cela n'est pas bon car ce n'est pas
				la responsabilité de Jeu. Jeu devrait plutôt <em>demander</em> au Personnage de se déplacer en appelant une de ses méthodes (de la classe
				Personnage), et ensuite c'est le perso lui-même qui ferait son propre déplacement selon sa propre logique. Ainsi il pourrait éviter de sortir du
				Terrain par exemple, mais on pourrait aussi ajouter d'autres contraintes facilement plus tard.</p>
<p>Ajouter dans la classe Personnage une méthode pour se déplacer. La méthode prend 2 paramètres (en plus de <code>self</code>):</p>
<ol>
<li>un <code>int</code> pour le nombres de cases de déplacement horizontalement sur le terrain du perso</li>
<li>un second <code>int</code> pour verticalement</li>
</ol>
<p>C'est dans cette méthode qu'on empêche le Personnage de sortir de son terrain.</p>
</li>
<li>Dans méthode <code>démarrer</code> de la classe Jeu, utiliser la nouvelle méthode de Personnage pour déplacer le perso joueur.
			</li>
<li>Vérifier que ça fonctionne: le perso ne devrait plus pouvoir sortir du terrain.</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os

					class Personnage:
						# ↓ On a ajouté le paramètre terrain, et l'attribut du même nom,
						# ce qui permettra à chaque Personnage de savoir
						# sur quel Terrain il existera.
						def __init__(self, nom_initial, pv_max, caractère_apparence, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractère_apparence = caractère_apparence
							self.terrain = terrain

						# ↓ On a ajouté cette méthode
						def déplacer(self, déplacement_x, déplacement_y):
							if 0 &lt;= self.position[0] + déplacement_x &lt; self.terrain.taille_x:
								self.position[0] += déplacement_x
							if 0 &lt;= self.position[1] + déplacement_y &lt; self.terrain.taille_y:
								self.position[1] += déplacement_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins négatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soigné de", soins_effectifs, "points")

						def blesser(self, points_de_dégâts):
							if points_de_dégâts &gt; 0:
								vie_avant_dégâts = self.points_de_vie
								self.points_de_vie -= points_de_dégâts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dégâts, "dégâts")
								else:
									print(self.nom, "subit", points_de_dégâts, "dégâts")
							else:
								print("Dégâts négatifs ou zéro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						# ↓ On a retiré le paramètre perso,
						# et initialisé l'attribut perso à None.
						# Il faudra lui donner une valeur APRES l'instanciation du Terrain,
						# voir en fin de programme.
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									perso_présent_sur_case = False
									if self.perso.position == [i, j]:
										ligne += self.perso.caractère_apparence + " "
										perso_présent_sur_case = True
									if not perso_présent_sur_case:
										ligne += "· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso):
							self.terrain = terrain
							self.perso = perso

						def démarrer(self):
							action_utilisateur = ""
							while action_utilisateur != "qq":
								os.system("cls")
								self.terrain.dessiner()
								self.perso.saluer()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.déplacer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.déplacer(1, 0)
								elif action_utilisateur == "z":
									self.perso.déplacer(0, -1)
								elif action_utilisateur == "s":
									self.perso.déplacer(0, 1)


					terrain = Terrain(5, 5)
					perso1 = Personnage("Toto", 100, "@", 2, 1, terrain)
					# ↓ On n'oublie pas donner une valeur à l'attribut "perso" du terrain,
					# après la création du Personnage
					terrain.perso = perso1
					jeu = Jeu(terrain, perso1)
					jeu.démarrer()
				</code></pre>
<p>Remarque: on est obligé de retirer le paramètre "perso" du constructeur de Terrain, car alors on aurait une situation "circulaire" impossible
					à satisfaire: il faudrait un Terrain pour construire un Personnage, mais il faudraitt aussi le Personnage pour construire le Terrain
					associé. Dans ce genre de situation l'une des deux entités doit être initialisée en deux temps comme dans ce cas présent.</p>
</div>
		
	</div>

	
	<div class="exercice">
<h2 data-nb="26.2" id="Question 2">Question 2</h2>
<p>On veut ajouter des murs sur notre terrain. Pour l'instant ils ne bloquent pas le perso du joueur.</p>
<video controls="" preload="none" src="img/tp6/q2.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li><p>Ajouter pour chaque Terrain un attribut qui est un tableau à 2 dimensions, dans lequel vous stockerez si oui ou non chaque case contient un
				mur ou pas. Un mur (et l'absence de mur) peut être représenté dans chaque case du tableau par un <code>int</code> (0 = un mur, autre valeur =
				pas de mur par exemple) ou un <code>bool</code> (<code>True</code> = un mur, <code>False</code> = pas de mur), au choix.</p>
<p>On peut considérer qu'un Terrain ne contient aucun mur après sa création, ils seront ajoutés un par un en modifiant directement son tableau
					de murs.</p>
</li>
<li><p>Modifier la méthode <code>déssiner</code> de la classe <code>Terrain</code> pour prendre en compte les murs et les dessiner. Vous pouvez
				utiliser deux fois le caractère "█" pour faire un carré dans la console, comme ceci: ██. Les cases vides sont toujours dessinées avec le
				caractère "·" à ne pas confondre avec le point "."</p>
<p>Quand un Personnage se trouve sur la même case qu'un mur, c'est lui qui est dessiné, pas le mur, pour éviter de perdre de vue le perso du
					joueur.</p>
</li>
<li>Après la création du Terrain, en bas du programme, lui ajouter quelques murs avant de lancer le Jeu, et vérifier que vous les voyez. Mais vous
				pouvez passer à travers pour le moment.
			</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os

					class Personnage:
						def __init__(self, nom_initial, pv_max, caractère_apparence, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractère_apparence = caractère_apparence
							self.terrain = terrain

						def déplacer(self, déplacement_x, déplacement_y):
							if 0 &lt;= self.position[0] + déplacement_x &lt; self.terrain.taille_x:
								self.position[0] += déplacement_x
							if 0 &lt;= self.position[1] + déplacement_y &lt; self.terrain.taille_y:
								self.position[1] += déplacement_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins négatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soigné de", soins_effectifs, "points")

						def blesser(self, points_de_dégâts):
							if points_de_dégâts &gt; 0:
								vie_avant_dégâts = self.points_de_vie
								self.points_de_vie -= points_de_dégâts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dégâts, "dégâts")
								else:
									print(self.nom, "subit", points_de_dégâts, "dégâts")
							else:
								print("Dégâts négatifs ou zéro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							# ↓ Ajout du tableau à deux dimensions qui contiendra les murs.
							# Chaque case contiendra la valeur None si pas de mur à sa position,
							# ou le int 0 si un mur est présent.
							# On utilise une "compréhension" de liste pour avoir un tableau 2d facilement,
							# si vous ne savez pas ce que c'est voir le CM4, structures de données.
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								# ↓ Maintenant on dessine aussi les murs quand ils sont présents
								for i in range(self.taille_x):
									if self.perso.position == [i, j]:
										ligne += self.perso.caractère_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "██"
									else:
										ligne += "· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso):
							self.terrain = terrain
							self.perso = perso

						def démarrer(self):
							action_utilisateur = ""
							while action_utilisateur != "qq":
								os.system("cls")
								self.terrain.dessiner()
								self.perso.saluer()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.déplacer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.déplacer(1, 0)
								elif action_utilisateur == "z":
									self.perso.déplacer(0, -1)
								elif action_utilisateur == "s":
									self.perso.déplacer(0, 1)


					terrain = Terrain(5, 5)
					perso1 = Personnage("Toto", 100, "@", 2, 1, terrain)
					terrain.perso = perso1
					# ↓ On rajoute des murs "manuellement" un par un une fois le Terrain créé
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					jeu = Jeu(terrain, perso1)
					jeu.démarrer()
				</code></pre>
</div>
		
	</div>

	
	<div class="exercice">
<h2 data-nb="26.3" id="Question 3">Question 3</h2>
<p>Maintenant on veut empêcher le perso du joueur de passer à travers les murs.</p>
<video controls="" preload="none" src="img/tp6/q3.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Ajouter les contraintes nécessaires, dans la méthode pour se déplacer de la classe Personnage, que vous avez ajoutée précédemment.
			</li>
<li>Sur votre Terrain, créez une pièce, des murs et divers obstacles.</li>
<li>Vérifiez que le perso du joueur est bloqué par les murs.</li>
</ol>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					import os

					class Personnage:
						def __init__(self, nom_initial, pv_max, caractère_apparence, x, y, terrain):
							self.nom = nom_initial
							self.points_de_vie = self.points_de_vie_max = pv_max
							self.position = [x, y]
							self.caractère_apparence = caractère_apparence
							self.terrain = terrain

						def déplacer(self, déplacement_x, déplacement_y):
							nouveau_x = self.position[0] + déplacement_x
							nouveau_y = self.position[1] + déplacement_y
							# ↓ On rajoute cette contrainte: on teste si aucun mur à la future position du Personnage.
							# Si on teste en dehors du Terrain (ce qui cause un IndexError) ou bien
							# si il y a un zéro dans la future case (ce qui signifie la présence d'un mur),
							# alors on termine immédiatement la fonction avec l'instruction "return".
							try:
								aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
							except IndexError:
								return
							if not aucun_obstacle:
								return
							if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
								self.position[0] = nouveau_x
							if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
								self.position[1] = nouveau_y

						def saluer(self):
							if self.points_de_vie &gt; 0:
								print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
									  + "/" + str(self.points_de_vie_max) + ". Position=(" \
									  + str(self.position[0]) + "," + str(self.position[1]) + ")")
							else:
								print(self.nom, "est mort")

						def soigner(self, points_de_soin):
							if self.points_de_vie &lt;= 0:
								print("Impossible de soigner un perso mort")
								return
							if points_de_soin &lt;= 0:
								print("Soins négatifs, impossible")
								return
							vie_avant_soins = self.points_de_vie
							soins_effectifs = points_de_soin
							self.points_de_vie += points_de_soin
							if self.points_de_vie &gt; self.points_de_vie_max:
								soins_effectifs = self.points_de_vie_max - vie_avant_soins
								self.points_de_vie = self.points_de_vie_max
							print(self.nom, "est soigné de", soins_effectifs, "points")

						def blesser(self, points_de_dégâts):
							if points_de_dégâts &gt; 0:
								vie_avant_dégâts = self.points_de_vie
								self.points_de_vie -= points_de_dégâts
								if self.points_de_vie &lt; 0:
									self.points_de_vie = 0
									print(self.nom, "subit", vie_avant_dégâts, "dégâts")
								else:
									print(self.nom, "subit", points_de_dégâts, "dégâts")
							else:
								print("Dégâts négatifs ou zéro interdits pour", self.nom)

						def attaquer(self, perso_cible):
							print(self.nom, "attaque", perso_cible.nom)
							perso_cible.blesser(25)


					class Terrain:
						def __init__(self, taille_x, taille_y):
							self.taille_x = taille_x
							self.taille_y = taille_y
							self.perso = None
							self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

						def dessiner(self):
							for j in range(self.taille_y):
								ligne = ""
								for i in range(self.taille_x):
									if self.perso.position == [i, j]:
										ligne += self.perso.caractère_apparence + " "
									elif self.cases[i][j] == 0:
										ligne += "██"
									else:
										ligne += "· "
								print(ligne)


					class Jeu:
						def __init__(self, terrain, perso: Personnage):
							self.terrain = terrain
							self.perso = perso

						def démarrer(self):
							action_utilisateur = ""
							while action_utilisateur != "qq":
								os.system("cls")
								self.terrain.dessiner()
								self.perso.saluer()
								action_utilisateur = input("Action: ")
								if action_utilisateur == "q":
									self.perso.déplacer(-1, 0)
								elif action_utilisateur == "d":
									self.perso.déplacer(1, 0)
								elif action_utilisateur == "z":
									self.perso.déplacer(0, -1)
								elif action_utilisateur == "s":
									self.perso.déplacer(0, 1)


					terrain = Terrain(10, 10)
					perso1 = Personnage("Toto", 100, "@", 1, 1, terrain)
					terrain.perso = perso1
					# ↓ On place des murs pour former des obstacles un peu intéressants,
					# comme une pièce par exemple.
					# mur haut gauche
					terrain.cases[0][0] = 0
					terrain.cases[1][0] = 0
					terrain.cases[2][0] = 0
					terrain.cases[2][1] = 0
					terrain.cases[2][2] = 0
					terrain.cases[2][3] = 0
					terrain.cases[3][3] = 0
					# pièce en bas
					terrain.cases[4][9] = 0
					terrain.cases[5][9] = 0
					terrain.cases[6][9] = 0
					terrain.cases[7][9] = 0
					terrain.cases[8][9] = 0

					terrain.cases[4][8] = 0
					terrain.cases[4][7] = 0
					terrain.cases[4][6] = 0

					terrain.cases[8][8] = 0
					terrain.cases[8][7] = 0
					terrain.cases[8][6] = 0

					terrain.cases[6][6] = 0
					terrain.cases[7][6] = 0

					terrain.cases[3][7] = 0
					terrain.cases[2][7] = 0
					jeu = Jeu(terrain, perso1)
					jeu.démarrer()
				</code></pre>
</div>
		
	</div>


		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
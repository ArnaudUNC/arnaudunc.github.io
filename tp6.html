<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>✏️ TP 6 - Prog. objets niv.4 ✔️ | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<link rel="icon" href="img/favicon.svg">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="hsl(200,50%, 50%)" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75">
		Algo et prog 2
	</text>
	<text x="50" y="90">
		en Python
	</text>
</svg>

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="index.html#Introduction">
					Introduction
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="groupes.html#Groupes de TD / TP">
					Groupes de TD / TP
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="cm1.html#📖 Cours 1: rappels">
					📖 Cours 1: rappels
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="td1.html#✏️ TD 1 - Calculatrice niv.1 ✔️">
					✏️ TD 1 - Calculatrice niv.1 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp1.html#✏️ TP 1 - Calculatrice niv.2 ✔️">
					✏️ TP 1 - Calculatrice niv.2 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp2.html#✏️ TP 2 - Calculatrice niv.3 ✔️">
					✏️ TP 2 - Calculatrice niv.3 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp3.html#✏️ TP 3 - Calculatrice niv.4 ✔️">
					✏️ TP 3 - Calculatrice niv.4 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="cm2.html#📖 Cours 2: Programmation orientée objets">
					📖 Cours 2: Programmation orientée objets
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="td2.html#✏️ TD 2 - Prog. objets niv.1 ✔️">
					✏️ TD 2 - Prog. objets niv.1 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp4.html#✏️ TP 4 - Prog. objets niv.2 ✔️">
					✏️ TP 4 - Prog. objets niv.2 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☒</span-->
				<a href="tp5.html#✏️ TP 5 - Prog. objets niv.3 ✔️">
					✏️ TP 5 - Prog. objets niv.3 ✔️
				</a>
			</div>
	

	
			<div class="page_actuelle h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="#✏️ TP 6 - Prog. objets niv.4 ✔️">
					✏️ TP 6 - Prog. objets niv.4 ✔️
				</a>
			</div>
			<div class="page_actuelle h h2">
				<!--span class="ballot_box">☐</span-->
				<a href="#Question 1">
					Question 1
				</a>
			</div>
			<div class="page_actuelle h h2">
				<!--span class="ballot_box">☐</span-->
				<a href="#Question 2">
					Question 2
				</a>
			</div>
			<div class="page_actuelle h h2">
				<!--span class="ballot_box">☐</span-->
				<a href="#Question 3">
					Question 3
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="tp7.html#✏️ TP 7 - Prog. objets niv.5 ✔️">
					✏️ TP 7 - Prog. objets niv.5 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cm3.html#📖 Cours 3: fonctionnalités de Python">
					📖 Cours 3: fonctionnalités de Python
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="td3.html#✏️ TD 3 ✔️">
					✏️ TD 3 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cm4.html#📖 Cours 4: rappels et compléments">
					📖 Cours 4: rappels et compléments
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="tp8.html#✏️ TP 8 ✔️">
					✏️ TP 8 ✔️
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="tp9.html#✏️ TP 9 - Jeu du pendu niv.1">
					✏️ TP 9 - Jeu du pendu niv.1
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="exos_notes.html#📝 Exercices notés">
					📝 Exercices notés
				</a>
			</div>
	

	
			<div class="h h1">
				<!--span class="ballot_box">☐</span-->
				<a href="cc1_2021.html#📝 Contrôle continu 1">
					📝 Contrôle continu 1
				</a>
			</div>
	

	</div>
	<div id="contenu">
		

		<div class="nav_arrows">
		<div style="display: flex; flex-direction: row; justify-content: space-between; padding: 1em 0em;">
				<span>
					
						<a href="tp5.html">← Page précédente</a>
					
				</span>
			
				<span style="padding: 0 .5em;">
						<a href="index.html">1ère page</a>
					</span>
			
			<span>
				
					<a href="tp7.html">Page suivante →</a>
				
				</span>
		</div>
		</div>
		<hr>

		
	<h1 data-nb="12" id="✏️ TP 6 - Prog. objets niv.4 ✔️">✏️ TP 6 - Prog. objets niv.4 ✔️</h1>
<p>Ce TP est la suite directe du TP 5.</p>
<div class="exercice">
<h2 data-nb="12.1" id="Question 1">Question 1</h2>
<p>On continue de modifier le programme du dernier exercice du TP précédent.</p>
<p>On veut qu'il soit impossible pour un Personnage de sortir du Terrain, il faut le restreindre dans l'aire de jeu.</p>
<video controls="" preload="none" src="img/tp6/q1.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>chaque Personnage aura besoin de savoir sur quel Terrain il se trouve, donc ajouter un attribut (par exemple <code>terrain</code>) dans le
				constructeur de Personnage. Le Terrain doit être spécifié au moment de la création du perso, donc ajouter également un paramètre au
				constructeur, et initialiser la valeur de l'attribut avec la valeur du paramètre.
			</li>
<li><p>Jusqu'à présent, le déplacement du Personnage se fait en modifiant sa position depuis la classe Jeu, mais cela n'est pas bon car ce n'est pas
				la responsabilité de Jeu. Jeu devrait plutôt <em>demander</em> au Personnage de se déplacer en appelant une de ses méthodes (de la classe
				Personnage), et ensuite c'est le perso lui-même qui ferait son propre déplacement selon sa propre logique. Ainsi il pourrait éviter de sortir du
				Terrain par exemple, mais on pourrait aussi ajouter d'autres contraintes facilement plus tard.</p>
<p>Ajouter dans la classe Personnage une méthode pour se déplacer. La méthode prend 2 paramètres (en plus de <code>self</code>):</p>
<ol>
<li>un <code>int</code> pour le nombres de cases de déplacement horizontalement sur le terrain du perso</li>
<li>un second <code>int</code> pour verticalement</li>
</ol>
<p>C'est dans cette méthode qu'on empêche le Personnage de sortir de son terrain.</p>
</li>
<li>Dans méthode <code>démarrer</code> de la classe Jeu, utiliser la nouvelle méthode de Personnage pour déplacer le perso joueur.
			</li>
<li>Vérifier que ça fonctionne: le perso ne devrait plus pouvoir sortir du terrain.</li>
</ol>
<div class="correction">
<pre class="line-numbers"><code class="language-python">
				import os

				class Personnage:
					# ↓ On a ajouté le paramètre terrain, et l'attribut du même nom,
					# ce qui permettra à chaque Personnage de savoir
					# sur quel Terrain il existera.
					def __init__(self, nom_initial, pv_max, char_apparence, x, y, terrain):
						self.nom = nom_initial
						self.points_de_vie = self.points_de_vie_max = pv_max
						self.position = [x, y]
						self.char_apparence = char_apparence
						self.terrain = terrain

					# ↓ On a ajouté cette méthode
					def déplacer(self, déplacement_x, déplacement_y):
						if 0 &lt;= self.position[0] + déplacement_x &lt; self.terrain.taille_x:
							self.position[0] += déplacement_x
						if 0 &lt;= self.position[1] + déplacement_y &lt; self.terrain.taille_y:
							self.position[1] += déplacement_y

					def saluer(self):
						if self.points_de_vie &gt; 0:
							print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
								  + "/" + str(self.points_de_vie_max) + ". Position=(" \
								  + str(self.position[0]) + "," + str(self.position[1]) + ")")
						else:
							print(self.nom, "est mort")

					def soigner(self, points_de_soin):
						if self.points_de_vie &lt;= 0:
							print("Impossible de soigner un perso mort")
							return
						if points_de_soin &lt;= 0:
							print("Soins négatifs, impossible")
							return
						vie_avant_soins = self.points_de_vie
						soins_effectifs = points_de_soin
						self.points_de_vie += points_de_soin
						if self.points_de_vie &gt; self.points_de_vie_max:
							soins_effectifs = self.points_de_vie_max - vie_avant_soins
							self.points_de_vie = self.points_de_vie_max
						print(self.nom, "est soigné de", soins_effectifs, "points")

					def blesser(self, points_de_dégâts):
						if points_de_dégâts &gt; 0:
							vie_avant_dégâts = self.points_de_vie
							self.points_de_vie -= points_de_dégâts
							if self.points_de_vie &lt; 0:
								self.points_de_vie = 0
								print(self.nom, "subit", vie_avant_dégâts, "dégâts")
							else:
								print(self.nom, "subit", points_de_dégâts, "dégâts")
						else:
							print("Dégâts négatifs ou zéro interdits pour", self.nom)

					def attaquer(self, perso_cible):
						print(self.nom, "attaque", perso_cible.nom)
						perso_cible.blesser(25)


				class Terrain:
					# ↓ On a retiré le paramètre perso,
					# et initialisé l'attribut perso à None.
					# Il faudra lui donner une valeur APRES l'instanciation du Terrain,
					# voir en fin de programme.
					def __init__(self, taille_x, taille_y):
						self.taille_x = taille_x
						self.taille_y = taille_y
						self.perso = None

					def dessiner(self):
						for j in range(self.taille_y):
							ligne = ""
							for i in range(self.taille_x):
								perso_présent_sur_case = False
								if self.perso.position == [i, j]:
									ligne += self.perso.char_apparence + " "
									perso_présent_sur_case = True
								if not perso_présent_sur_case:
									ligne += "· "
							print(ligne)


				class Jeu:
					def __init__(self, terrain, perso):
						self.terrain = terrain
						self.perso = perso

					def démarrer(self):
						action_utilisateur = ""
						while action_utilisateur != "qq":
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							action_utilisateur = input("Action: ")
							if action_utilisateur == "q":
								self.perso.déplacer(-1, 0)
							elif action_utilisateur == "d":
								self.perso.déplacer(1, 0)
							elif action_utilisateur == "z":
								self.perso.déplacer(0, -1)
							elif action_utilisateur == "s":
								self.perso.déplacer(0, 1)


				terrain = Terrain(5, 5)
				perso1 = Personnage("Toto", 100, "@", 2, 1, terrain)
				# ↓ On n'oublie pas donner une valeur à l'attribut "perso" du terrain,
				# après la création du Personnage
				terrain.perso = perso1
				jeu = Jeu(terrain, perso1)
				jeu.démarrer()
			</code></pre>
<p>Remarque: on est obligé de retirer le paramètre "perso" du constructeur de Terrain, car alors on aurait une situation "circulaire" impossible à
				satisfaire: il faudrait un Terrain pour construire un Personnage, mais il faudraitt aussi le Personnage pour construire le Terrain associé. Dans
				ce genre de situation l'une des deux entités doit être initialisée en deux temps comme dans ce cas présent.</p>
</div>
</div>
<div class="exercice">
<h2 data-nb="12.2" id="Question 2">Question 2</h2>
<p>On veut ajouter des murs sur notre terrain. Pour l'instant ils ne bloquent pas le perso du joueur.</p>
<video controls="" preload="none" src="img/tp6/q2.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li><p>Ajouter pour chaque Terrain un attribut qui est un tableau à 2 dimensions, dans lequel vous stockerez si oui ou non chaque case contient un
				mur ou pas. Un mur (et l'absence de mur) peut être représenté dans chaque case du tableau par un <code>int</code> (0 = un mur, autre valeur =
				pas de mur par exemple) ou un <code>bool</code> (<code>True</code> = un mur, <code>False</code> = pas de mur), au choix.</p>
<p>On peut considérer qu'un Terrain ne contient aucun mur après sa création, ils seront ajoutés un par un en modifiant directement son tableau
					de murs.</p>
</li>
<li><p>Modifier la méthode <code>déssiner</code> de la classe <code>Terrain</code> pour prendre en compte les murs et les dessiner. Vous pouvez
				utiliser deux fois le caractère "█" pour faire un carré dans la console, comme ceci: ██. Les cases vides sont toujours dessinées avec le
				caractère "·" à ne pas confondre avec le point "."</p>
<p>Quand un Personnage se trouve sur la même case qu'un mur, c'est lui qui est dessiné, pas le mur, pour éviter de perdre de vue le perso du
					joueur.</p>
</li>
<li>Après la création du Terrain, en bas du programme, lui ajouter quelques murs avant de lancer le Jeu, et vérifier que vous les voyez. Mais vous
				pouvez passer à travers pour le moment.
			</li>
</ol>
<div class="correction">
<pre class="line-numbers"><code class="language-python">
				import os

				class Personnage:
					def __init__(self, nom_initial, pv_max, char_apparence, x, y, terrain):
						self.nom = nom_initial
						self.points_de_vie = self.points_de_vie_max = pv_max
						self.position = [x, y]
						self.char_apparence = char_apparence
						self.terrain = terrain

					def déplacer(self, déplacement_x, déplacement_y):
						if 0 &lt;= self.position[0] + déplacement_x &lt; self.terrain.taille_x:
							self.position[0] += déplacement_x
						if 0 &lt;= self.position[1] + déplacement_y &lt; self.terrain.taille_y:
							self.position[1] += déplacement_y

					def saluer(self):
						if self.points_de_vie &gt; 0:
							print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
								  + "/" + str(self.points_de_vie_max) + ". Position=(" \
								  + str(self.position[0]) + "," + str(self.position[1]) + ")")
						else:
							print(self.nom, "est mort")

					def soigner(self, points_de_soin):
						if self.points_de_vie &lt;= 0:
							print("Impossible de soigner un perso mort")
							return
						if points_de_soin &lt;= 0:
							print("Soins négatifs, impossible")
							return
						vie_avant_soins = self.points_de_vie
						soins_effectifs = points_de_soin
						self.points_de_vie += points_de_soin
						if self.points_de_vie &gt; self.points_de_vie_max:
							soins_effectifs = self.points_de_vie_max - vie_avant_soins
							self.points_de_vie = self.points_de_vie_max
						print(self.nom, "est soigné de", soins_effectifs, "points")

					def blesser(self, points_de_dégâts):
						if points_de_dégâts &gt; 0:
							vie_avant_dégâts = self.points_de_vie
							self.points_de_vie -= points_de_dégâts
							if self.points_de_vie &lt; 0:
								self.points_de_vie = 0
								print(self.nom, "subit", vie_avant_dégâts, "dégâts")
							else:
								print(self.nom, "subit", points_de_dégâts, "dégâts")
						else:
							print("Dégâts négatifs ou zéro interdits pour", self.nom)

					def attaquer(self, perso_cible):
						print(self.nom, "attaque", perso_cible.nom)
						perso_cible.blesser(25)


				class Terrain:
					def __init__(self, taille_x, taille_y):
						self.taille_x = taille_x
						self.taille_y = taille_y
						self.perso = None
						# ↓ Ajout du tableau à deux dimensions qui contiendra les murs.
						# Chaque case contiendra la valeur None si pas de mur à sa position,
						# ou le int 0 si un mur est présent.
						# On utilise une "compréhension" de liste pour avoir un tableau 2d facilement,
						# si vous ne savez pas ce que c'est voir le CM4, structures de données.
						self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

					def dessiner(self):
						for j in range(self.taille_y):
							ligne = ""
							# ↓ Maintenant on dessine aussi les murs quand ils sont présents
							for i in range(self.taille_x):
								if self.perso.position == [i, j]:
									ligne += self.perso.char_apparence + " "
								elif self.cases[i][j] == 0:
									ligne += "██"
								else:
									ligne += "· "
							print(ligne)


				class Jeu:
					def __init__(self, terrain, perso):
						self.terrain = terrain
						self.perso = perso

					def démarrer(self):
						action_utilisateur = ""
						while action_utilisateur != "qq":
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							action_utilisateur = input("Action: ")
							if action_utilisateur == "q":
								self.perso.déplacer(-1, 0)
							elif action_utilisateur == "d":
								self.perso.déplacer(1, 0)
							elif action_utilisateur == "z":
								self.perso.déplacer(0, -1)
							elif action_utilisateur == "s":
								self.perso.déplacer(0, 1)


				terrain = Terrain(5, 5)
				perso1 = Personnage("Toto", 100, "@", 2, 1, terrain)
				terrain.perso = perso1
				# ↓ On rajoute des murs "manuellement" un par un une fois le Terrain créé
				terrain.cases[0][0] = 0
				terrain.cases[1][0] = 0
				terrain.cases[2][0] = 0
				terrain.cases[2][1] = 0
				terrain.cases[2][2] = 0
				terrain.cases[2][3] = 0
				terrain.cases[3][3] = 0
				jeu = Jeu(terrain, perso1)
				jeu.démarrer()
			</code></pre>
</div>
</div>
<div class="exercice">
<h2 data-nb="12.3" id="Question 3">Question 3</h2>
<p>Maintenant on veut empêcher le perso du joueur de passer à travers les murs.</p>
<video controls="" preload="none" src="img/tp6/q3.mp4"></video>
<p>Faites selon la façon qui vous convient, ou utilisez la façon ci-dessous:</p>
<ol>
<li>Ajouter les contraintes nécessaires, dans la méthode pour se déplacer de la classe Personnage, que vous avez ajoutée précédemment.
			</li>
<li>Sur votre Terrain, créez une pièce, des murs et divers obstacles.</li>
<li>Vérifiez que le perso du joueur est bloqué par les murs.</li>
</ol>
<div class="correction">
<pre class="line-numbers"><code class="language-python">
				import os

				class Personnage:
					def __init__(self, nom_initial, pv_max, char_apparence, x, y, terrain):
						self.nom = nom_initial
						self.points_de_vie = self.points_de_vie_max = pv_max
						self.position = [x, y]
						self.char_apparence = char_apparence
						self.terrain = terrain

					def déplacer(self, déplacement_x, déplacement_y):
						nouveau_x = self.position[0] + déplacement_x
						nouveau_y = self.position[1] + déplacement_y
						# ↓ On rajoute cette contrainte: on teste si aucun mur à la future position du Personnage.
						# Si on teste en dehors du Terrain (ce qui cause un IndexError) ou bien
						# si il y a un zéro dans la future case (ce qui signifie la présence d'un mur),
						# alors on termine immédiatement la fonction avec l'instruction "return".
						try:
							aucun_obstacle = self.terrain.cases[nouveau_x][nouveau_y] != 0
						except IndexError:
							return
						if not aucun_obstacle:
							return
						if 0 &lt;= nouveau_x &lt; self.terrain.taille_x:
							self.position[0] = nouveau_x
						if 0 &lt;= nouveau_y &lt; self.terrain.taille_y:
							self.position[1] = nouveau_y

					def saluer(self):
						if self.points_de_vie &gt; 0:
							print("Bonjour, je suis " + self.nom + ": vie=" + str(self.points_de_vie) \
								  + "/" + str(self.points_de_vie_max) + ". Position=(" \
								  + str(self.position[0]) + "," + str(self.position[1]) + ")")
						else:
							print(self.nom, "est mort")

					def soigner(self, points_de_soin):
						if self.points_de_vie &lt;= 0:
							print("Impossible de soigner un perso mort")
							return
						if points_de_soin &lt;= 0:
							print("Soins négatifs, impossible")
							return
						vie_avant_soins = self.points_de_vie
						soins_effectifs = points_de_soin
						self.points_de_vie += points_de_soin
						if self.points_de_vie &gt; self.points_de_vie_max:
							soins_effectifs = self.points_de_vie_max - vie_avant_soins
							self.points_de_vie = self.points_de_vie_max
						print(self.nom, "est soigné de", soins_effectifs, "points")

					def blesser(self, points_de_dégâts):
						if points_de_dégâts &gt; 0:
							vie_avant_dégâts = self.points_de_vie
							self.points_de_vie -= points_de_dégâts
							if self.points_de_vie &lt; 0:
								self.points_de_vie = 0
								print(self.nom, "subit", vie_avant_dégâts, "dégâts")
							else:
								print(self.nom, "subit", points_de_dégâts, "dégâts")
						else:
							print("Dégâts négatifs ou zéro interdits pour", self.nom)

					def attaquer(self, perso_cible):
						print(self.nom, "attaque", perso_cible.nom)
						perso_cible.blesser(25)


				class Terrain:
					def __init__(self, taille_x, taille_y):
						self.taille_x = taille_x
						self.taille_y = taille_y
						self.perso = None
						self.cases = [[None for j in range(taille_y)] for i in range(taille_x)]

					def dessiner(self):
						for j in range(self.taille_y):
							ligne = ""
							for i in range(self.taille_x):
								if self.perso.position == [i, j]:
									ligne += self.perso.char_apparence + " "
								elif self.cases[i][j] == 0:
									ligne += "██"
								else:
									ligne += "· "
							print(ligne)


				class Jeu:
					def __init__(self, terrain, perso: Personnage):
						self.terrain = terrain
						self.perso = perso

					def démarrer(self):
						action_utilisateur = ""
						while action_utilisateur != "qq":
							os.system("cls")
							self.terrain.dessiner()
							self.perso.saluer()
							action_utilisateur = input("Action: ")
							if action_utilisateur == "q":
								self.perso.déplacer(-1, 0)
							elif action_utilisateur == "d":
								self.perso.déplacer(1, 0)
							elif action_utilisateur == "z":
								self.perso.déplacer(0, -1)
							elif action_utilisateur == "s":
								self.perso.déplacer(0, 1)


				terrain = Terrain(10, 10)
				perso1 = Personnage("Toto", 100, "@", 1, 1, terrain)
				terrain.perso = perso1
				# ↓ On place des murs pour former des obstacles un peu intéressants,
				# comme une pièce par exemple.
				# mur haut gauche
				terrain.cases[0][0] = 0
				terrain.cases[1][0] = 0
				terrain.cases[2][0] = 0
				terrain.cases[2][1] = 0
				terrain.cases[2][2] = 0
				terrain.cases[2][3] = 0
				terrain.cases[3][3] = 0
				# pièce en bas
				terrain.cases[4][9] = 0
				terrain.cases[5][9] = 0
				terrain.cases[6][9] = 0
				terrain.cases[7][9] = 0
				terrain.cases[8][9] = 0

				terrain.cases[4][8] = 0
				terrain.cases[4][7] = 0
				terrain.cases[4][6] = 0

				terrain.cases[8][8] = 0
				terrain.cases[8][7] = 0
				terrain.cases[8][6] = 0

				terrain.cases[6][6] = 0
				terrain.cases[7][6] = 0

				terrain.cases[3][7] = 0
				terrain.cases[2][7] = 0
				jeu = Jeu(terrain, perso1)
				jeu.démarrer()
			</code></pre>
</div>
</div>



		<div class="nav_arrows">
			<hr>
			
		<div style="display: flex; flex-direction: row; justify-content: space-between; padding: 1em 0em;">
				<span>
					
						<a href="tp5.html">← Page précédente</a>
					
				</span>
			
				<span style="padding: 0 .5em;">
						<a href="index.html">1ère page</a>
					</span>
			
			<span>
				
					<a href="tp7.html">Page suivante →</a>
				
				</span>
		</div>
		
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>✏️ TP 1 - Calculatrice niv.2 | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		🐍

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Par Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_spec_impl_versions.html">
				Spécification, implémentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_methodes_exec.html">
				Façons d'exécuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_memoire_donnees.html">
				Mémoire et modèle de données
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_sequences.html">
				Les séquences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avancées sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_fonc_params.html">
				Fonctions et paramètres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_compr_listes.html">
				Compréhension de listes et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☒</span-->
			<a href="td1.html">
				✏️ TD 1 - Calculatrice niv.1
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp1.html">
				✏️ TP 1 - Calculatrice niv.2
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp2.html">
				✏️ TP 2 - Calculatrice niv.3
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="tp3.html">
				✏️ TP 3 - Calculatrice niv.4
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="td2.html">
				✏️ TD 2 - Prog. objets niv.1
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">☐</span-->
			<a href="td3.html">
				✏️ TD 3
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	<h1 data-nb="18" id="✏️ TP 1 - Calculatrice niv.2">✏️ TP 1 - Calculatrice niv.2</h1>
	

	
	<div class="exercice">
<h2 data-nb="18.1" id="Question 1">Question 1</h2>
<p>Partant de la solution de la dernière question du TD précédent, on veut maintenant en plus forcer l'utilisateur à entrer des nombres, et pas juste
			stopper le programme avec un message dans le cas contraire. Pour cela, demander à l'utilisateur le 1er nombre indéfiniment tant qu'il / elle n'a pas
			entré un nombre correct, en précisant bien à chaque fois ce qui est attendu, et afficher à chaque fois l'erreur (texte entré n'est pas un nombre).
			Faire de même pour le second nombre.</p>
<p>On veut aussi que l'utilisateur puisse entrer des nombres à virgule, comme par exemple 2.5, 8.04, etc...</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				# Obtenir nombre 1.
				# ↓ On part du fait que nb1 n'est pas un nombre, même si on ne le connait pas encore
				nb1_est_pas_un_nombre = True
				# ↓ Ainsi la boucle peut être exécutée au moins une fois
				while nb1_est_pas_un_nombre:
					# ↓ On récupère nb1 sous forme de str
					# ↓ On reste en dehors du try car aucune erreur possible encore
					nb1 = input("Entrez nombre 1: ")
					try:
						# ↓ On tente de convertir nb1 en float
						# ↓ Cela peut provoquer une erreur, donc on doit être dans un bloc try
						nb1 = float(nb1)
						# ↓ si ça a fonctionné, on change la variable pour stopper la boucle
						nb1_est_pas_un_nombre = False
					except:
						# En cas d'erreur dans le bloc try, ce bloc sera exécuté
						print(nb1, "n'est pas un nombre")

				# Obtenir nombre 2: on fait exactement la même chose que pour nb1.
				nb2_est_pas_un_nombre = True
				while nb2_est_pas_un_nombre:
					nb2 = input("Entrez nombre 2: ")
					try:
						nb2 = float(nb2)
						nb2_est_pas_un_nombre = False
					except:
						print(nb2, "n'est pas un nombre")

				# Obtenir opérateur.
				op = input("Operation? (+,-,*,/): ")

				# Execution de l'opération.
				# On a juste retiré le try-except par rapport à l'exercice précédent,
				# car plus rien ici ne provoque d'erreur potentielle.
				if op == "+":
					print(nb1, op, nb2, "=", nb1 + nb2)
				elif op == "-":
					print(nb1, op, nb2, "=", nb1 - nb2)
				elif op == "*":
					print(nb1, op, nb2, "=", nb1 * nb2)
				elif op == "/":
					print(nb1, op, nb2, "=", nb1 / nb2)
				else:
					print("Opération inconnue: ", op)
			</code></pre>
<pre class="affichage_console"><code>
Entrez nombre 1: 4.2
Entrez nombre 2: 5
Operation? (+,-,*,/): +
4.2 + 5.0 = 9.2
&gt;</code></pre>
<pre class="affichage_console"><code>
Entrez nombre 1: t
t n'est pas un nombre
Entrez nombre 1: y
y n'est pas un nombre
Entrez nombre 1: 4.2
Entrez nombre 2: 5
Operation? (+,-,*,/): +
4.2 + 5.0 = 9.2
&gt;</code></pre>
<p>Remarques:</p>
<ul>
<li>On utilise la fonction <code>float()</code> au lieu de <code>int()</code>, pour que l'utilisateur puisse entrer des nombres à virgule.
					</li>
<li>Bien nommer ses variables est très important. <code>nb1_est_pas_un_nombre</code> décrit bien ce que la variable est censée avoir comme
						valeur, et donc aide à comprendre son rôle dans le programme. Son type de donnée est également clair par son nom: c'est vrai ou c'est
						faux, c'est donc un <code>bool</code>. Si on l'avait nommée <code>nb_correct</code> par exemple, on pourrait croire en lisant le code
						que la variable contient le nombre correct lui-même, ce qui n'est pas le cas. Un nom trop court comme <code>x</code> ou <code>a</code>,
						ne donnerait aucune information, rendrait le programme difficile à lire, et augmenterait les probabilité d'écrire du code incorrect.
					</li>
<li><p>On a écrit à la ligne 14 <code class="language-python">nb1_est_pas_un_nombre = False</code> ce qui veut dire qu'on a donc bien <code>nb1</code>
						sous forme de nombre (sous forme de <code>float</code> et non plus sous forme de <code>str</code>), hors comment peut-on être sûr de ça
						à cette ligne?</p>
<p>Parce que dans un bloc <code>try:</code>, chaque ligne peut s'exécuter à condition que toutes les précédentes (du bloc
							<code>try:</code>) ont bien pu être exécutées sans erreur. La première ligne du bloc qui provoquera une erreur stoppera
							immédiatement le bloc <code>try:</code>, et c'est le bloc <code>except:</code> qui va démarrer.</p>
<p>Ainsi, à la ligne 14, la ligne 12 s'est forcément bien exécutée, ce qui veut dire que l'appel à la fonction <code>float(nb1)</code> a
							réussi, et que donc <code>nb1</code> a pu être converti de <code>str</code> vers <code>float</code> sans problème.</p>
</li>
<li>
<p> Pour tester si une variable ne contient pas un nombre, certains écrivent le test suivant: (qui est faux, et inutile, voir plus bas
							pourquoi)</p>
<pre><code class="language-python">
						nb = "10"
						# ↓ La condition vaut True car "10" est différent du type int.
						if nb != int:
							print("Pas un nombre")
					</code></pre>
<p>Le test est faux, car il compare <strong>la valeur</strong> de la variable avec le type <code>int</code>, hors il faudrait comparer
							<strong>le type</strong> de la valeur de la variable. Vous savez obtenir le type d'une donnée avec la fonction pré-définie <code>type()</code>.
							Donc la version correcte serait:</p>
<pre><code class="language-python">
						nb = "10"
						# ↓ La condition vaut encore True car le type de "10" est str,
						# hors str != int,
						# donc nb n'est toujours PAS considéré comme un nombre.
						if type(nb) != int:
							print("Pas un nombre")
					</code></pre>
<p>De toute façon cette approche est inutile pour cet exercice, car on ne peut obtenir le nombre de l'utilisateur que sous forme de
							<code>str</code> en premier lieu, grâce à la fonction <code>input()</code>. Puis il faut tenter de convertir en nombre avec un appel
							à <code>int()</code> ou <code>float()</code>. Ces appels provoqueront une erreur si le texte de l'utilisateur ne représente pas un
							nombre, le test <code>type(nb) != int</code> ne pourra donc jamais être utilisé car il y aura erreur avant. Seules les exceptions
							avec des blocs <code>try-except</code> peuvent nous aider dans cette situation.</p>
</li>
<li>
<p>Une version alternative avec une seule boucle <code>while</code> pour les deux nombres, au lieu de chacun sa boucle:</p>
<pre class="line-numbers"><code class="language-python">
						nb1_est_pas_un_nombre = True
						nb2_est_pas_un_nombre = True
						while nb1_est_pas_un_nombre or nb2_est_pas_un_nombre:
							if nb1_est_pas_un_nombre:
								nb1 = input("Entrez nombre 1: ")
								try:
									nb1 = float(nb1)
									nb1_est_pas_un_nombre = False
								except:
									print(nb1, "n'est pas un nombre")

							if nb2_est_pas_un_nombre:
								nb2 = input("Entrez nombre 2: ")
								try:
									nb2 = float(nb2)
									nb2_est_pas_un_nombre = False
								except:
									print(nb2, "n'est pas un nombre")

						# Obtenir opérateur
						op = input("Operation? (+,-,*,/): ")

						# Execution de l'opération
						if op == "+":
							print(nb1, op, nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, op, nb2, "=", nb1 - nb2)
						elif op == "*":
							print(nb1, op, nb2, "=", nb1 * nb2)
						elif op == "/":
							print(nb1, op, nb2, "=", nb1 / nb2)
						else:
							print("Opération inconnue: ", op)
					</code></pre>
<p>Cette solution est un peu moins pratique pour l'utilisateur car si le premier nombre n'en est pas un, le message d'erreur s'affiche,
							mais le nombre 2 est demandé ensuite, au lieu de redemander nb1. De plus, cette solution s'adapte mal pour la question suivante,
							donc privilégier la première approche.</p>
</li>
</ul>
</div>
		
	</div>


	
	<div class="exercice">
<h2 data-nb="18.2" id="Question 2">Question 2</h2>
<p>Dans cette question, on n'ajoute aucune nouvelle fonctionnalité à notre programme, on adapte simplement le code pour le simplifier et le
			raccourcir.</p>
<p>Partant de la solution de la question précédente, on veut simplifier le code en éliminant le code redondant (<em>redondant</em> signifie
			<em>dupliqué</em>, <em>identique</em>, <em>répété</em>). On peut voir qu'on fait pratiquement la même chose pour obtenir chacun des deux nombres
			<code>nb1</code> et <code>nb2</code>, donc mettre dans une fonction le code pour obtenir un seul nombre. </p>
<p>Donner un nom explicite à la fonction, de façon à ce qu'on comprenne, rien que par son nom, ce qu'elle est censée faire et censée retourner comme
			résultat.</p>
<p>Puis appeler cette fonction 2 fois: une fois pour obtenir de l'utilisateur le 1er nombre, puis une seconde fois pour obtenir le 2ème nombre.</p>
<p>Le reste du programme reste inchangé.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				# On définit notre fonction, en lui donnant un nom explicite.
				# Aucun paramètre n'est nécessaire pour ce qu'on souhaite faire.
				def obtenir_nb_de_utilisateur():
					# Le code à l'intérieur est identique à la question précédente.
					# On change juste nb1 ou nb2 en nb, car la fonction ne se
					# préoccupe que de récupérer un seul nombre,
					# et de retourner ce nombre: la fonction ne se préoccupe pas
					# de à quoi servira ce nombre, elle fait juste son travail à elle.
					nb_est_pas_un_nombre = True
					while nb_est_pas_un_nombre:
						nb = input("Entrez un nombre: ")
						try:
							nb = float(nb)
							nb_est_pas_un_nombre = False
						except:
							print(nb, "n'est pas un nombre")
					# ↓ On n'oublie surtout pas de retourner,
					# au code qui va appeler cette fonction,
					# le nombre de l'utilisateur.
					return nb

				# ↓ On peut maintenant appeller notre fonction 2 fois,
				# pour obtenir nos deux nombres.
				nb1 = obtenir_nb_de_utilisateur()
				nb2 = obtenir_nb_de_utilisateur()

				# ↓ Le reste est identique à la question précédente ↓

				# Opérateur
				op = input("Operation? (+,-,*,/): ")

				# Execution de l'opération
				if op == "+":
					print(nb1, op, nb2, "=", nb1 + nb2)
				elif op == "-":
					print(nb1, op, nb2, "=", nb1 - nb2)
				elif op == "*":
					print(nb1, op, nb2, "=", nb1 * nb2)
				elif op == "/":
					print(nb1, op, nb2, "=", nb1 / nb2)
				else:
					print("Opération inconnue: ", op)
			</code></pre>
<pre class="affichage_console"><code>
Entrez un nombre: 3.5
Entrez un nombre: 1.1
Operation? (+,-,*,/): +
3.5 + 1.1 = 4.6
&gt;</code></pre>
<pre class="affichage_console"><code>
Entrez un nombre: y
y n'est pas un nombre
Entrez un nombre: u
u n'est pas un nombre
Entrez un nombre: 4.5
Entrez un nombre: i
i n'est pas un nombre
Entrez un nombre: p
p n'est pas un nombre
Entrez un nombre: 6
Operation? (+,-,*,/): +
4.5 + 6.0 = 10.5
&gt;</code></pre>
<p>Remarques:</p>
<ul>
<li><p>A l'affichage, l'utilisateur ne sait plus s'il entre le 1er ou le 2ème nombre, car le message est identique dans les deux cas. Pour
						éviter ça on pourrait rajouter un paramètre à notre fonction pour modifier le message si besoin, au moment de l'appel de la fonction.
						Par exemple:</p>
<pre class="line-numbers"><code class="language-python">
						# On rajoute un paramètre pour contrôler le message.
						# Le nom du paramètre est important, il doit décrire son rôle,
						# et donner une information sur le type attendu, ici c'est à dire str.
						def obtenir_nb_de_utilisateur(message):
							nb_est_pas_un_nombre = True
							while nb_est_pas_un_nombre:
								# ↓ On utilise le paramètre message ici:
								# on le passe comme paramètre à la fonction input().
								nb = input(message)
								try:
									nb = float(nb)
									nb_est_pas_un_nombre = False
								except:
									print(nb, "n'est pas un nombre")
							return nb

						# ↓ On peut désormais passer un message différent à chaque appel.
						nb1 = obtenir_nb_de_utilisateur("Nombre 1: ")
						nb2 = obtenir_nb_de_utilisateur("Nombre 2: ")


						op = input("Operation? (+,-,*,/): ")
						if op == "+":
							print(nb1, op, nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, op, nb2, "=", nb1 - nb2)
						elif op == "*":
							print(nb1, op, nb2, "=", nb1 * nb2)
						elif op == "/":
							print(nb1, op, nb2, "=", nb1 / nb2)
						else:
							print("Opération inconnue: ", op)
					</code></pre>
<pre class="affichage_console"><code>
Nombre 1: 4
Nombre 2: 5
Operation? (+,-,*,/): +
4.0 + 5.0 = 9.0
&gt;</code></pre>
<pre class="affichage_console"><code>
Nombre 1: y
y n'est pas un nombre
Nombre 1: u
u n'est pas un nombre
Nombre 1: 4
Nombre 2: 5
Operation? (+,-,*,/): +
4.0 + 5.0 = 9.0
&gt;</code></pre>
</li>
</ul>
</div>
		
	</div>
	
	<div class="exercice">
<h2 data-nb="18.3" id="Question 3">Question 3</h2>
<p>Partant de la solution de l'exercice précédent, forcer l'utilisateur à ne pouvoir entrer que l'une des 4 opérations autorisées: addition,
			soustraction, division, multiplication.</p>
<p>S'il / elle entre n'importe quoi d'autre, le programme affiche un message d'erreur adapté, et redemande encore et encore l'opération, jusqu'à ce que
			celle-ci soit l'une de celles permises.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre


					# Obtenir nombres
					nb1 = avoir_nombre_utilisateur("Nombre 1: ")
					nb2 = avoir_nombre_utilisateur("Nombre 2: ")

					# Obtenir op
					opération_est_correcte = False
					while not opération_est_correcte:
						op = input("Opération (+,-,*,/): ")
						# ↓ L'opérateur booléen "in" renvoit True ou False.
						# True si ce qui est à sa gauche EST DANS la séquence à sa droite,
						# donc ici si op est égal à n'importe lequel des éléments de la liste.
						opération_est_correcte = op in ["+", "-", "/", "*", ]
						if not opération_est_correcte:
							print(op, "n'est pas une opération supportée")

					# Calculer et afficher résultat
					if op == "+":
						print(nb1, "+", nb2, "=", nb1 + nb2)
					elif op == "-":
						print(nb1, "-", nb2, "=", nb1 - nb2)
					elif op == "/":
						print(nb1, "/", nb2, "=", nb1 / nb2)
					else:
						print(nb1, "*", nb2, "=", nb1 * nb2)
				</code></pre>
<p>Remarques:</p>
<ul>
<li><p>Ne pas confondre le <code>try-except</code> avec le <code>if-else</code>.</p>
<p><code>if-else</code> sert à faire telle ou telle action selon une condition, par exemple si l'utilisateur n'a pas entré une opération
							supportée (+,-,/,*). </p>
<p><code>try-except</code> sert à garder le contrôle sur l'exécution du programme en cas d'erreur (erreur au sens exécution impossible
							par Python, pas une erreur du point de vue de l'utilisateur), par exemple si on tente de transformer en <code>int</code> ou <code>float</code>
							le texte de l'utilisateur.</p>
</li>
<li><p>Comment savoir s'il faut utiliser <code>try-except</code> ou <code>if-else</code>?</p>
<p>Si un morceau de code que vous voulez exécuter peut provoquer des erreurs qui sont affichées en rouge dans la console, et qui
							stoppent le programme, il faut un <code>try-except</code> pour intercepter l'erreur si elle survient, et vous permettre de continuer
							l'exécution du programme.</p>
<p>Si le code ne provoque pas d'erreur potentiellement, mais que vous voulez faire des actions différentes selon une condition, alors
							utiliser un <code>if-else</code>. </p></li>
<li><p>Une version alternative de <code>op in ["+", "-", "/", "*", ]</code> pourrait être:</p>
<pre><code class="language-python">
						opération_est_correcte = op == "+" or op == "-" or op == "/" or op == "*"
					</code></pre>
</li>
</ul>
</div>
		
	</div>


	
	<div class="exercice">
<h2 data-nb="18.4" id="Question 4">Question 4</h2>
<p>Partant de la solution de l'exercice précédent, répéter l'ensemble du programme indéfiniment, pour permettre à l'utilisateur de faire autant de
			calculs qu'il / elle souhaite.</p>
<p>A chaque fois qu'un calcul a été réalisé, demander à l'utilisateur s'il / elle souhaite continuer ou arrêter. Si l'utilisateur décide d'arrêter, le
			programme se termine. Sinon il recommence en demandant à nouveaux deux nombre, l'opération et affiche le résultat.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				def avoir_nombre_utilisateur(message):
					nb_est_correct = False
					while not nb_est_correct:
						txt_utilisateur = input(message)
						try:
							nombre = float(txt_utilisateur)
							nb_est_correct = True
						except:
							print(txt_utilisateur, "n'est pas un nombre")
					return nombre

				# Boucle pour répéter les calculs
				utilisateur_veut_continuer = True
				while utilisateur_veut_continuer:
					nb1 = avoir_nombre_utilisateur("Nombre 1: ")
					nb2 = avoir_nombre_utilisateur("Nombre 2: ")

					opération_est_correcte = False
					while not opération_est_correcte:
						op = input("Opération (+,-,*,/): ")
						opération_est_correcte = op in ["+", "-", "/", "*", ]
						if not opération_est_correcte:
							print(op, "n'est pas une opération supportée")

					if op == "+":
						print(nb1, "+", nb2, "=", nb1 + nb2)
					elif op == "-":
						print(nb1, "-", nb2, "=", nb1 - nb2)
					elif op == "/":
						print(nb1, "/", nb2, "=", nb1 / nb2)
					else:
						print(nb1, "*", nb2, "=", nb1 * nb2)

					# Demander utilisateur si veut continuer
					réponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
					utilisateur_veut_continuer = réponse_utilisateur == "o"
			</code></pre>
<p>Remarques:</p>
<ul>
<li><p>Sur la dernière ligne, ne pas confondre <code>=</code> avec <code>==</code>.</p>
<p><code>==</code> est un opérateur booléen, qui vaut <code>True</code> quand les deux éléments à gauche et à droite sont égaux. Sur
							cette ligne de code en particulier, <code>==</code> est exécuté en premier, et vaut <code>True</code> si
							<code>réponse_utilisateur</code> est égal à <code>"o"</code>, <code>False</code> sinon.</p>
<p><code>=</code> est l'instruction d'affectation de valeur à une variable, et sera exécuté APRÈS le <code>==</code>, c'est à dire la
							variable <code>utilisateur_veut_continuer</code> prendra la valeur du résultat du test <code>==</code> (c'est à dire
							<code>True</code> ou <code>False</code>).</p>
</li>
</ul>
</div>
		
	</div>
	
	<div class="exercice">
<h2 data-nb="18.5" id="Question 5">Question 5</h2>
<p>Partant de la solution de l'exercice précédent, on veut rendre le code plus lisible et simple à comprendre. On n'ajoute aucune nouvelle
			fonctionnalité du point de vue de l'utilisateur, on adapte le code pour l'améliorer.</p>
<p>Mettre dans une fonction tout le code qui sert à un seul calcul, et donc PAS le code qui sert à répéter les calculs si l'utilisateur souhaite en
			faire d'autres. Utiliser / exécuter ensuite cette fonction avec le code qui répète les caluls.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre


					# Définition de notre seconde fonction
					def faire_calcul_utilisateur():
						nb1 = avoir_nombre_utilisateur("Nombre 1: ")

						opération_est_correcte = False
						while not opération_est_correcte:
							op = input("Opération (+,-,*,/): ")
							opération_est_correcte = op in ["+", "-", "/", "*", ]
							if not opération_est_correcte:
								print(op, "n'est pas une opération supportée")

						nb2 = avoir_nombre_utilisateur("Nombre 2: ")

						if op == "+":
							print(nb1, "+", nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, "-", nb2, "=", nb1 - nb2)
						elif op == "/":
							print(nb1, "/", nb2, "=", nb1 / nb2)
						else:
							print(nb1, "*", nb2, "=", nb1 * nb2)


					utilisateur_veut_continuer = True
					while utilisateur_veut_continuer:

						# Appel de la fonction
						faire_calcul_utilisateur()

						réponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
						utilisateur_veut_continuer = réponse_utilisateur == "o"
				</code></pre>
<p>Remarques:</p>
<ul>
<li>On exécute notre fonction <code>avoir_nombre_utilisateur</code> dans notre seconde fonction <code>faire_calcul_utilisateur</code>. Il
						est fréquent en programmation d'utiliser nos fonctions dans d'autres de nos fonctions.
					</li>
<li><p>La fonction <code>avoir_nombre_utilisateur</code> retourne un résultat avec l'instruction <code>return</code>. En revanche la
						fonction <code>faire_calcul_utilisateur</code> ne retourne aucun résultat, car c'est ce qu'on souhaite: qu'elle fasse tout le travail de
						demander les nombres et l'opérateur à l'utilisateur et lui affiche le résultat. On a décidé que la fonction ne sert pas à renvoyer un
						quelconque résultat, seul nous importe qu'elle fasse ce qu'elle doit faire.</p>
<p>Dans notre boucle <code>while</code> tout en bas, on veut juste appeler la fonction, et qu'elle fasse <em>elle-même</em> tout le
							calcul et l'affichage. Dans ce cas, un <code>return</code> dans la fonction est inutile.</p>
<p>Rappelez-vous cependant que même si on n'écrit aucun <code>return</code>, une fonction retourne quand même <code>None</code> par
							défaut. </p></li>
</ul>
</div>
		
	</div>



	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	<div class="exercice">
<h2 data-nb="18.7" id="Question 6">Question 6</h2>
<p>On ne va pas ajouter de nouvelle fonctionnalité à notre programme, mais on va utiliser une autre approche que les exceptions (qui sont l'approche
			idéale dans le contexte de cet exercice) pour savoir si un nombre entré par l'utilisateur est correct ou pas.</p>
<p>Copiez-collez la fonction qui vous sert à obtenir un nombre de l'utilisateur, afin d'avoir une copie et de garder l'originale intacte. Dans cette
			copie, que vous renommerez avec un nom adapté, n'utilisez plus les exceptions. Testez "à la main" (par votre propre code) si le texte entré est un
			nombre correct (à virgule ou entier, et avec signe négatif présent ou pas). Vous aurez besoin de connaître <code>break</code> et
			<code>continue</code> pour vous faciliter la tâche, à lire dans le cours, partie sur les boucles avancées.</p>
<p>Attention cette modification ne doit pas changer le comportement de la fonction, c'est-à-dire si le texte entré n'est pas un nombre, il faut le
			redemander encore à l'utilisateur jusqu'à ce qu'un nombre correct soit entré.</p>
<p>Utilisez votre nouvelle fonction dans votre programme pour la tester.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur_exceptions(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre

					def avoir_nombre_utilisateur_verif_manuelle(message):
						txt_utilisateur_est_un_nombre = False
						while not txt_utilisateur_est_un_nombre:
							txt_utilisateur = input(message)
							indice_départ = 0
							signe = txt_utilisateur[indice_départ]
							virgule_rencontrée = False
							if signe == "-":
								indice_départ += 1
							txt_utilisateur_est_un_nombre = True
							for i in range(indice_départ, len(txt_utilisateur)):
								c = txt_utilisateur[i]
								if c == ".":
									if not virgule_rencontrée:
										virgule_rencontrée = True
									else:
										print(txt_utilisateur, "n'est pas un nombre")
										txt_utilisateur_est_un_nombre = False
										break
								elif c not in "0123456789":
									print(txt_utilisateur, "n'est pas un nombre")
									txt_utilisateur_est_un_nombre = False
									break

						return float(txt_utilisateur)


					# Définition de notre seconde fonction
					def faire_calcul_utilisateur():
						nb1 = avoir_nombre_utilisateur_verif_manuelle("Nombre 1: ")

						opération_est_correcte = False
						while not opération_est_correcte:
							op = input("Opération (+,-,*,/): ")
							opération_est_correcte = op in ["+", "-", "/", "*", ]
							if not opération_est_correcte:
								print(op, "n'est pas une opération supportée")

						nb2 = avoir_nombre_utilisateur_verif_manuelle("Nombre 2: ")

						if op == "+":
							print(nb1, "+", nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, "-", nb2, "=", nb1 - nb2)
						elif op == "/":
							print(nb1, "/", nb2, "=", nb1 / nb2)
						else:
							print(nb1, "*", nb2, "=", nb1 * nb2)


					utilisateur_veut_continuer = True
					while utilisateur_veut_continuer:
						# Appel de la fonction
						faire_calcul_utilisateur()

						réponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
						utilisateur_veut_continuer = réponse_utilisateur == "o"
				</code></pre>
</div>
		
	</div>


		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E 🐍 %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la première ligne des <pre><code> qui est considérée toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un élément détruit tous ses éléments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un élément texte
	});

	// On ajoute un <br> avant et après chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.noté');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>↓ Affichage dans la console (ou dans le shell, selon où vous lancez l'exécution)<mall>`;
		p.classList.add("légende_placée_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_à_cliquer">📝 Afficher / cacher correction ✓</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>
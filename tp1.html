<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>‚úèÔ∏è TP 1 - Calculatrice niv.2 | Algo et prog 2 en Python</title>
	<link href="prism.css" rel="stylesheet"/>
	<link href="style.css" rel="stylesheet"/>
	<!--link rel="icon" href="img/favicon.svg"-->
	<link rel="icon"
			href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3C!--	%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E üêç %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E">
</head>
<body>
<div id="conteneur">
	<div id="side_nav_bar">
		<!--svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100" style="display:block; margin:auto; padding: 0 0 1em 0;">
	<style>
		text {
			text-align: center;
			fill: white;
			text-anchor: middle;
			font-size: 11pt;
		}
	</style>
	<rect fill="#4B8BBE" x="0" y="0" width="100" height="100"></rect>
	<text x="50" y="45" style="font-size: 30pt;">
		üêç

	</text>
	<text x="50" y="75" fill="#FFE873">
		Algo et prog 2
	</text>
	<text x="50" y="90" fill="#FFE873">
		en Python
	</text>
</svg-->

<div style="color:#4B8BBE; font-size: 200%; padding: 2%; text-align: center">
	Algo. et prog. 2 en
</div>
<img src="img/python-logo-generic.png" alt="Logo de Python" style="width: 100%; max-width: 19em; display:block; margin:auto;">
<div style="text-align: center; opacity: 0.5; font-size: small">Par Arnaud COUTURIER - Python 3.10</div>


























		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="index.html">
				Introduction
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_spec_impl_versions.html">
				Sp√©cification, impl√©mentations et versions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_methodes_exec.html">
				Fa√ßons d'ex√©cuter un programme Python
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_memoire_donnees.html">
				M√©moire et mod√®le de donn√©es
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_pass.html">
				L'instruction pass
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_prog_objets.html">
				Programmation objets
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_namespaces_modules.html">
				Namespaces et modules
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_exceptions.html">
				Les exceptions
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_sequences.html">
				Les s√©quences
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_iterables.html">
				Iterables, iterators
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_iterable_unpacking.html">
				Iterable unpacking
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_boucles_avancees.html">
				Techniques avanc√©es sur les boucles
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_fonc_params.html">
				Fonctions et param√®tres
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_dict_set.html">
				Hash et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_compr_listes.html">
				Compr√©hension de listes et dictionnaires
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="cm_manip_fich_texte.html">
				Manipulation de fichiers texte
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òí</span-->
			<a href="td1.html">
				‚úèÔ∏è TD 1 - Calculatrice niv.1
			</a>
		</div>

		<div class="page_actuelle h h1">
			<!--span class="ballot_box">‚òê</span-->
			<a href="tp1.html">
				‚úèÔ∏è TP 1 - Calculatrice niv.2
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òê</span-->
			<a href="tp2.html">
				‚úèÔ∏è TP 2 - Calculatrice niv.3
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òê</span-->
			<a href="tp3.html">
				‚úèÔ∏è TP 3 - Calculatrice niv.4
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òê</span-->
			<a href="td2.html">
				‚úèÔ∏è TD 2 - Prog. objets niv.1
			</a>
		</div>

		<div class=" h h1">
			<!--span class="ballot_box">‚òê</span-->
			<a href="td3.html">
				‚úèÔ∏è TD 3
			</a>
		</div>

	</div>
	<div id="contenu">
		


		
	<h1 data-nb="18" id="‚úèÔ∏è TP 1 - Calculatrice niv.2">‚úèÔ∏è TP 1 - Calculatrice niv.2</h1>
	

	
	<div class="exercice">
<h2 data-nb="18.1" id="Question 1">Question 1</h2>
<p>Partant de la solution de la derni√®re question du TD pr√©c√©dent, on veut maintenant en plus forcer l'utilisateur √† entrer des nombres, et pas juste
			stopper le programme avec un message dans le cas contraire. Pour cela, demander √† l'utilisateur le 1er nombre ind√©finiment tant qu'il / elle n'a pas
			entr√© un nombre correct, en pr√©cisant bien √† chaque fois ce qui est attendu, et afficher √† chaque fois l'erreur (texte entr√© n'est pas un nombre).
			Faire de m√™me pour le second nombre.</p>
<p>On veut aussi que l'utilisateur puisse entrer des nombres √† virgule, comme par exemple 2.5, 8.04, etc...</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				# Obtenir nombre 1.
				# ‚Üì On part du fait que nb1 n'est pas un nombre, m√™me si on ne le connait pas encore
				nb1_est_pas_un_nombre = True
				# ‚Üì Ainsi la boucle peut √™tre ex√©cut√©e au moins une fois
				while nb1_est_pas_un_nombre:
					# ‚Üì On r√©cup√®re nb1 sous forme de str
					# ‚Üì On reste en dehors du try car aucune erreur possible encore
					nb1 = input("Entrez nombre 1: ")
					try:
						# ‚Üì On tente de convertir nb1 en float
						# ‚Üì Cela peut provoquer une erreur, donc on doit √™tre dans un bloc try
						nb1 = float(nb1)
						# ‚Üì si √ßa a fonctionn√©, on change la variable pour stopper la boucle
						nb1_est_pas_un_nombre = False
					except:
						# En cas d'erreur dans le bloc try, ce bloc sera ex√©cut√©
						print(nb1, "n'est pas un nombre")

				# Obtenir nombre 2: on fait exactement la m√™me chose que pour nb1.
				nb2_est_pas_un_nombre = True
				while nb2_est_pas_un_nombre:
					nb2 = input("Entrez nombre 2: ")
					try:
						nb2 = float(nb2)
						nb2_est_pas_un_nombre = False
					except:
						print(nb2, "n'est pas un nombre")

				# Obtenir op√©rateur.
				op = input("Operation? (+,-,*,/): ")

				# Execution de l'op√©ration.
				# On a juste retir√© le try-except par rapport √† l'exercice pr√©c√©dent,
				# car plus rien ici ne provoque d'erreur potentielle.
				if op == "+":
					print(nb1, op, nb2, "=", nb1 + nb2)
				elif op == "-":
					print(nb1, op, nb2, "=", nb1 - nb2)
				elif op == "*":
					print(nb1, op, nb2, "=", nb1 * nb2)
				elif op == "/":
					print(nb1, op, nb2, "=", nb1 / nb2)
				else:
					print("Op√©ration inconnue: ", op)
			</code></pre>
<pre class="affichage_console"><code>
Entrez nombre 1: 4.2
Entrez nombre 2: 5
Operation? (+,-,*,/): +
4.2 + 5.0 = 9.2
&gt;</code></pre>
<pre class="affichage_console"><code>
Entrez nombre 1: t
t n'est pas un nombre
Entrez nombre 1: y
y n'est pas un nombre
Entrez nombre 1: 4.2
Entrez nombre 2: 5
Operation? (+,-,*,/): +
4.2 + 5.0 = 9.2
&gt;</code></pre>
<p>Remarques:</p>
<ul>
<li>On utilise la fonction <code>float()</code> au lieu de <code>int()</code>, pour que l'utilisateur puisse entrer des nombres √† virgule.
					</li>
<li>Bien nommer ses variables est tr√®s important. <code>nb1_est_pas_un_nombre</code> d√©crit bien ce que la variable est cens√©e avoir comme
						valeur, et donc aide √† comprendre son r√¥le dans le programme. Son type de donn√©e est √©galement clair par son nom: c'est vrai ou c'est
						faux, c'est donc un <code>bool</code>. Si on l'avait nomm√©e <code>nb_correct</code> par exemple, on pourrait croire en lisant le code
						que la variable contient le nombre correct lui-m√™me, ce qui n'est pas le cas. Un nom trop court comme <code>x</code> ou <code>a</code>,
						ne donnerait aucune information, rendrait le programme difficile √† lire, et augmenterait les probabilit√© d'√©crire du code incorrect.
					</li>
<li><p>On a √©crit √† la ligne 14 <code class="language-python">nb1_est_pas_un_nombre = False</code> ce qui veut dire qu'on a donc bien <code>nb1</code>
						sous forme de nombre (sous forme de <code>float</code> et non plus sous forme de <code>str</code>), hors comment peut-on √™tre s√ªr de √ßa
						√† cette ligne?</p>
<p>Parce que dans un bloc <code>try:</code>, chaque ligne peut s'ex√©cuter √† condition que toutes les pr√©c√©dentes (du bloc
							<code>try:</code>) ont bien pu √™tre ex√©cut√©es sans erreur. La premi√®re ligne du bloc qui provoquera une erreur stoppera
							imm√©diatement le bloc <code>try:</code>, et c'est le bloc <code>except:</code> qui va d√©marrer.</p>
<p>Ainsi, √† la ligne 14, la ligne 12 s'est forc√©ment bien ex√©cut√©e, ce qui veut dire que l'appel √† la fonction <code>float(nb1)</code> a
							r√©ussi, et que donc <code>nb1</code> a pu √™tre converti de <code>str</code> vers <code>float</code> sans probl√®me.</p>
</li>
<li>
<p> Pour tester si une variable ne contient pas un nombre, certains √©crivent le test suivant: (qui est faux, et inutile, voir plus bas
							pourquoi)</p>
<pre><code class="language-python">
						nb = "10"
						# ‚Üì La condition vaut True car "10" est diff√©rent du type int.
						if nb != int:
							print("Pas un nombre")
					</code></pre>
<p>Le test est faux, car il compare <strong>la valeur</strong> de la variable avec le type <code>int</code>, hors il faudrait comparer
							<strong>le type</strong> de la valeur de la variable. Vous savez obtenir le type d'une donn√©e avec la fonction pr√©-d√©finie <code>type()</code>.
							Donc la version correcte serait:</p>
<pre><code class="language-python">
						nb = "10"
						# ‚Üì La condition vaut encore True car le type de "10" est str,
						# hors str != int,
						# donc nb n'est toujours PAS consid√©r√© comme un nombre.
						if type(nb) != int:
							print("Pas un nombre")
					</code></pre>
<p>De toute fa√ßon cette approche est inutile pour cet exercice, car on ne peut obtenir le nombre de l'utilisateur que sous forme de
							<code>str</code> en premier lieu, gr√¢ce √† la fonction <code>input()</code>. Puis il faut tenter de convertir en nombre avec un appel
							√† <code>int()</code> ou <code>float()</code>. Ces appels provoqueront une erreur si le texte de l'utilisateur ne repr√©sente pas un
							nombre, le test <code>type(nb) != int</code> ne pourra donc jamais √™tre utilis√© car il y aura erreur avant. Seules les exceptions
							avec des blocs <code>try-except</code> peuvent nous aider dans cette situation.</p>
</li>
<li>
<p>Une version alternative avec une seule boucle <code>while</code> pour les deux nombres, au lieu de chacun sa boucle:</p>
<pre class="line-numbers"><code class="language-python">
						nb1_est_pas_un_nombre = True
						nb2_est_pas_un_nombre = True
						while nb1_est_pas_un_nombre or nb2_est_pas_un_nombre:
							if nb1_est_pas_un_nombre:
								nb1 = input("Entrez nombre 1: ")
								try:
									nb1 = float(nb1)
									nb1_est_pas_un_nombre = False
								except:
									print(nb1, "n'est pas un nombre")

							if nb2_est_pas_un_nombre:
								nb2 = input("Entrez nombre 2: ")
								try:
									nb2 = float(nb2)
									nb2_est_pas_un_nombre = False
								except:
									print(nb2, "n'est pas un nombre")

						# Obtenir op√©rateur
						op = input("Operation? (+,-,*,/): ")

						# Execution de l'op√©ration
						if op == "+":
							print(nb1, op, nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, op, nb2, "=", nb1 - nb2)
						elif op == "*":
							print(nb1, op, nb2, "=", nb1 * nb2)
						elif op == "/":
							print(nb1, op, nb2, "=", nb1 / nb2)
						else:
							print("Op√©ration inconnue: ", op)
					</code></pre>
<p>Cette solution est un peu moins pratique pour l'utilisateur car si le premier nombre n'en est pas un, le message d'erreur s'affiche,
							mais le nombre 2 est demand√© ensuite, au lieu de redemander nb1. De plus, cette solution s'adapte mal pour la question suivante,
							donc privil√©gier la premi√®re approche.</p>
</li>
</ul>
</div>
		
	</div>


	
	<div class="exercice">
<h2 data-nb="18.2" id="Question 2">Question 2</h2>
<p>Dans cette question, on n'ajoute aucune nouvelle fonctionnalit√© √† notre programme, on adapte simplement le code pour le simplifier et le
			raccourcir.</p>
<p>Partant de la solution de la question pr√©c√©dente, on veut simplifier le code en √©liminant le code redondant (<em>redondant</em> signifie
			<em>dupliqu√©</em>, <em>identique</em>, <em>r√©p√©t√©</em>). On peut voir qu'on fait pratiquement la m√™me chose pour obtenir chacun des deux nombres
			<code>nb1</code> et <code>nb2</code>, donc mettre dans une fonction le code pour obtenir un seul nombre. </p>
<p>Donner un nom explicite √† la fonction, de fa√ßon √† ce qu'on comprenne, rien que par son nom, ce qu'elle est cens√©e faire et cens√©e retourner comme
			r√©sultat.</p>
<p>Puis appeler cette fonction 2 fois: une fois pour obtenir de l'utilisateur le 1er nombre, puis une seconde fois pour obtenir le 2√®me nombre.</p>
<p>Le reste du programme reste inchang√©.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				# On d√©finit notre fonction, en lui donnant un nom explicite.
				# Aucun param√®tre n'est n√©cessaire pour ce qu'on souhaite faire.
				def obtenir_nb_de_utilisateur():
					# Le code √† l'int√©rieur est identique √† la question pr√©c√©dente.
					# On change juste nb1 ou nb2 en nb, car la fonction ne se
					# pr√©occupe que de r√©cup√©rer un seul nombre,
					# et de retourner ce nombre: la fonction ne se pr√©occupe pas
					# de √† quoi servira ce nombre, elle fait juste son travail √† elle.
					nb_est_pas_un_nombre = True
					while nb_est_pas_un_nombre:
						nb = input("Entrez un nombre: ")
						try:
							nb = float(nb)
							nb_est_pas_un_nombre = False
						except:
							print(nb, "n'est pas un nombre")
					# ‚Üì On n'oublie surtout pas de retourner,
					# au code qui va appeler cette fonction,
					# le nombre de l'utilisateur.
					return nb

				# ‚Üì On peut maintenant appeller notre fonction 2 fois,
				# pour obtenir nos deux nombres.
				nb1 = obtenir_nb_de_utilisateur()
				nb2 = obtenir_nb_de_utilisateur()

				# ‚Üì Le reste est identique √† la question pr√©c√©dente ‚Üì

				# Op√©rateur
				op = input("Operation? (+,-,*,/): ")

				# Execution de l'op√©ration
				if op == "+":
					print(nb1, op, nb2, "=", nb1 + nb2)
				elif op == "-":
					print(nb1, op, nb2, "=", nb1 - nb2)
				elif op == "*":
					print(nb1, op, nb2, "=", nb1 * nb2)
				elif op == "/":
					print(nb1, op, nb2, "=", nb1 / nb2)
				else:
					print("Op√©ration inconnue: ", op)
			</code></pre>
<pre class="affichage_console"><code>
Entrez un nombre: 3.5
Entrez un nombre: 1.1
Operation? (+,-,*,/): +
3.5 + 1.1 = 4.6
&gt;</code></pre>
<pre class="affichage_console"><code>
Entrez un nombre: y
y n'est pas un nombre
Entrez un nombre: u
u n'est pas un nombre
Entrez un nombre: 4.5
Entrez un nombre: i
i n'est pas un nombre
Entrez un nombre: p
p n'est pas un nombre
Entrez un nombre: 6
Operation? (+,-,*,/): +
4.5 + 6.0 = 10.5
&gt;</code></pre>
<p>Remarques:</p>
<ul>
<li><p>A l'affichage, l'utilisateur ne sait plus s'il entre le 1er ou le 2√®me nombre, car le message est identique dans les deux cas. Pour
						√©viter √ßa on pourrait rajouter un param√®tre √† notre fonction pour modifier le message si besoin, au moment de l'appel de la fonction.
						Par exemple:</p>
<pre class="line-numbers"><code class="language-python">
						# On rajoute un param√®tre pour contr√¥ler le message.
						# Le nom du param√®tre est important, il doit d√©crire son r√¥le,
						# et donner une information sur le type attendu, ici c'est √† dire str.
						def obtenir_nb_de_utilisateur(message):
							nb_est_pas_un_nombre = True
							while nb_est_pas_un_nombre:
								# ‚Üì On utilise le param√®tre message ici:
								# on le passe comme param√®tre √† la fonction input().
								nb = input(message)
								try:
									nb = float(nb)
									nb_est_pas_un_nombre = False
								except:
									print(nb, "n'est pas un nombre")
							return nb

						# ‚Üì On peut d√©sormais passer un message diff√©rent √† chaque appel.
						nb1 = obtenir_nb_de_utilisateur("Nombre 1: ")
						nb2 = obtenir_nb_de_utilisateur("Nombre 2: ")


						op = input("Operation? (+,-,*,/): ")
						if op == "+":
							print(nb1, op, nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, op, nb2, "=", nb1 - nb2)
						elif op == "*":
							print(nb1, op, nb2, "=", nb1 * nb2)
						elif op == "/":
							print(nb1, op, nb2, "=", nb1 / nb2)
						else:
							print("Op√©ration inconnue: ", op)
					</code></pre>
<pre class="affichage_console"><code>
Nombre 1: 4
Nombre 2: 5
Operation? (+,-,*,/): +
4.0 + 5.0 = 9.0
&gt;</code></pre>
<pre class="affichage_console"><code>
Nombre 1: y
y n'est pas un nombre
Nombre 1: u
u n'est pas un nombre
Nombre 1: 4
Nombre 2: 5
Operation? (+,-,*,/): +
4.0 + 5.0 = 9.0
&gt;</code></pre>
</li>
</ul>
</div>
		
	</div>
	
	<div class="exercice">
<h2 data-nb="18.3" id="Question 3">Question 3</h2>
<p>Partant de la solution de l'exercice pr√©c√©dent, forcer l'utilisateur √† ne pouvoir entrer que l'une des 4 op√©rations autoris√©es: addition,
			soustraction, division, multiplication.</p>
<p>S'il / elle entre n'importe quoi d'autre, le programme affiche un message d'erreur adapt√©, et redemande encore et encore l'op√©ration, jusqu'√† ce que
			celle-ci soit l'une de celles permises.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre


					# Obtenir nombres
					nb1 = avoir_nombre_utilisateur("Nombre 1: ")
					nb2 = avoir_nombre_utilisateur("Nombre 2: ")

					# Obtenir op
					op√©ration_est_correcte = False
					while not op√©ration_est_correcte:
						op = input("Op√©ration (+,-,*,/): ")
						# ‚Üì L'op√©rateur bool√©en "in" renvoit True ou False.
						# True si ce qui est √† sa gauche EST DANS la s√©quence √† sa droite,
						# donc ici si op est √©gal √† n'importe lequel des √©l√©ments de la liste.
						op√©ration_est_correcte = op in ["+", "-", "/", "*", ]
						if not op√©ration_est_correcte:
							print(op, "n'est pas une op√©ration support√©e")

					# Calculer et afficher r√©sultat
					if op == "+":
						print(nb1, "+", nb2, "=", nb1 + nb2)
					elif op == "-":
						print(nb1, "-", nb2, "=", nb1 - nb2)
					elif op == "/":
						print(nb1, "/", nb2, "=", nb1 / nb2)
					else:
						print(nb1, "*", nb2, "=", nb1 * nb2)
				</code></pre>
<p>Remarques:</p>
<ul>
<li><p>Ne pas confondre le <code>try-except</code> avec le <code>if-else</code>.</p>
<p><code>if-else</code> sert √† faire telle ou telle action selon une condition, par exemple si l'utilisateur n'a pas entr√© une op√©ration
							support√©e (+,-,/,*). </p>
<p><code>try-except</code> sert √† garder le contr√¥le sur l'ex√©cution du programme en cas d'erreur (erreur au sens ex√©cution impossible
							par Python, pas une erreur du point de vue de l'utilisateur), par exemple si on tente de transformer en <code>int</code> ou <code>float</code>
							le texte de l'utilisateur.</p>
</li>
<li><p>Comment savoir s'il faut utiliser <code>try-except</code> ou <code>if-else</code>?</p>
<p>Si un morceau de code que vous voulez ex√©cuter peut provoquer des erreurs qui sont affich√©es en rouge dans la console, et qui
							stoppent le programme, il faut un <code>try-except</code> pour intercepter l'erreur si elle survient, et vous permettre de continuer
							l'ex√©cution du programme.</p>
<p>Si le code ne provoque pas d'erreur potentiellement, mais que vous voulez faire des actions diff√©rentes selon une condition, alors
							utiliser un <code>if-else</code>. </p></li>
<li><p>Une version alternative de <code>op in ["+", "-", "/", "*", ]</code> pourrait √™tre:</p>
<pre><code class="language-python">
						op√©ration_est_correcte = op == "+" or op == "-" or op == "/" or op == "*"
					</code></pre>
</li>
</ul>
</div>
		
	</div>


	
	<div class="exercice">
<h2 data-nb="18.4" id="Question 4">Question 4</h2>
<p>Partant de la solution de l'exercice pr√©c√©dent, r√©p√©ter l'ensemble du programme ind√©finiment, pour permettre √† l'utilisateur de faire autant de
			calculs qu'il / elle souhaite.</p>
<p>A chaque fois qu'un calcul a √©t√© r√©alis√©, demander √† l'utilisateur s'il / elle souhaite continuer ou arr√™ter. Si l'utilisateur d√©cide d'arr√™ter, le
			programme se termine. Sinon il recommence en demandant √† nouveaux deux nombre, l'op√©ration et affiche le r√©sultat.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
				def avoir_nombre_utilisateur(message):
					nb_est_correct = False
					while not nb_est_correct:
						txt_utilisateur = input(message)
						try:
							nombre = float(txt_utilisateur)
							nb_est_correct = True
						except:
							print(txt_utilisateur, "n'est pas un nombre")
					return nombre

				# Boucle pour r√©p√©ter les calculs
				utilisateur_veut_continuer = True
				while utilisateur_veut_continuer:
					nb1 = avoir_nombre_utilisateur("Nombre 1: ")
					nb2 = avoir_nombre_utilisateur("Nombre 2: ")

					op√©ration_est_correcte = False
					while not op√©ration_est_correcte:
						op = input("Op√©ration (+,-,*,/): ")
						op√©ration_est_correcte = op in ["+", "-", "/", "*", ]
						if not op√©ration_est_correcte:
							print(op, "n'est pas une op√©ration support√©e")

					if op == "+":
						print(nb1, "+", nb2, "=", nb1 + nb2)
					elif op == "-":
						print(nb1, "-", nb2, "=", nb1 - nb2)
					elif op == "/":
						print(nb1, "/", nb2, "=", nb1 / nb2)
					else:
						print(nb1, "*", nb2, "=", nb1 * nb2)

					# Demander utilisateur si veut continuer
					r√©ponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
					utilisateur_veut_continuer = r√©ponse_utilisateur == "o"
			</code></pre>
<p>Remarques:</p>
<ul>
<li><p>Sur la derni√®re ligne, ne pas confondre <code>=</code> avec <code>==</code>.</p>
<p><code>==</code> est un op√©rateur bool√©en, qui vaut <code>True</code> quand les deux √©l√©ments √† gauche et √† droite sont √©gaux. Sur
							cette ligne de code en particulier, <code>==</code> est ex√©cut√© en premier, et vaut <code>True</code> si
							<code>r√©ponse_utilisateur</code> est √©gal √† <code>"o"</code>, <code>False</code> sinon.</p>
<p><code>=</code> est l'instruction d'affectation de valeur √† une variable, et sera ex√©cut√© APR√àS le <code>==</code>, c'est √† dire la
							variable <code>utilisateur_veut_continuer</code> prendra la valeur du r√©sultat du test <code>==</code> (c'est √† dire
							<code>True</code> ou <code>False</code>).</p>
</li>
</ul>
</div>
		
	</div>
	
	<div class="exercice">
<h2 data-nb="18.5" id="Question 5">Question 5</h2>
<p>Partant de la solution de l'exercice pr√©c√©dent, on veut rendre le code plus lisible et simple √† comprendre. On n'ajoute aucune nouvelle
			fonctionnalit√© du point de vue de l'utilisateur, on adapte le code pour l'am√©liorer.</p>
<p>Mettre dans une fonction tout le code qui sert √† un seul calcul, et donc PAS le code qui sert √† r√©p√©ter les calculs si l'utilisateur souhaite en
			faire d'autres. Utiliser / ex√©cuter ensuite cette fonction avec le code qui r√©p√®te les caluls.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre


					# D√©finition de notre seconde fonction
					def faire_calcul_utilisateur():
						nb1 = avoir_nombre_utilisateur("Nombre 1: ")

						op√©ration_est_correcte = False
						while not op√©ration_est_correcte:
							op = input("Op√©ration (+,-,*,/): ")
							op√©ration_est_correcte = op in ["+", "-", "/", "*", ]
							if not op√©ration_est_correcte:
								print(op, "n'est pas une op√©ration support√©e")

						nb2 = avoir_nombre_utilisateur("Nombre 2: ")

						if op == "+":
							print(nb1, "+", nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, "-", nb2, "=", nb1 - nb2)
						elif op == "/":
							print(nb1, "/", nb2, "=", nb1 / nb2)
						else:
							print(nb1, "*", nb2, "=", nb1 * nb2)


					utilisateur_veut_continuer = True
					while utilisateur_veut_continuer:

						# Appel de la fonction
						faire_calcul_utilisateur()

						r√©ponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
						utilisateur_veut_continuer = r√©ponse_utilisateur == "o"
				</code></pre>
<p>Remarques:</p>
<ul>
<li>On ex√©cute notre fonction <code>avoir_nombre_utilisateur</code> dans notre seconde fonction <code>faire_calcul_utilisateur</code>. Il
						est fr√©quent en programmation d'utiliser nos fonctions dans d'autres de nos fonctions.
					</li>
<li><p>La fonction <code>avoir_nombre_utilisateur</code> retourne un r√©sultat avec l'instruction <code>return</code>. En revanche la
						fonction <code>faire_calcul_utilisateur</code> ne retourne aucun r√©sultat, car c'est ce qu'on souhaite: qu'elle fasse tout le travail de
						demander les nombres et l'op√©rateur √† l'utilisateur et lui affiche le r√©sultat. On a d√©cid√© que la fonction ne sert pas √† renvoyer un
						quelconque r√©sultat, seul nous importe qu'elle fasse ce qu'elle doit faire.</p>
<p>Dans notre boucle <code>while</code> tout en bas, on veut juste appeler la fonction, et qu'elle fasse <em>elle-m√™me</em> tout le
							calcul et l'affichage. Dans ce cas, un <code>return</code> dans la fonction est inutile.</p>
<p>Rappelez-vous cependant que m√™me si on n'√©crit aucun <code>return</code>, une fonction retourne quand m√™me <code>None</code> par
							d√©faut. </p></li>
</ul>
</div>
		
	</div>



	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	<div class="exercice">
<h2 data-nb="18.7" id="Question 6">Question 6</h2>
<p>On ne va pas ajouter de nouvelle fonctionnalit√© √† notre programme, mais on va utiliser une autre approche que les exceptions (qui sont l'approche
			id√©ale dans le contexte de cet exercice) pour savoir si un nombre entr√© par l'utilisateur est correct ou pas.</p>
<p>Copiez-collez la fonction qui vous sert √† obtenir un nombre de l'utilisateur, afin d'avoir une copie et de garder l'originale intacte. Dans cette
			copie, que vous renommerez avec un nom adapt√©, n'utilisez plus les exceptions. Testez "√† la main" (par votre propre code) si le texte entr√© est un
			nombre correct (√† virgule ou entier, et avec signe n√©gatif pr√©sent ou pas). Vous aurez besoin de conna√Ætre <code>break</code> et
			<code>continue</code> pour vous faciliter la t√¢che, √† lire dans le cours, partie sur les boucles avanc√©es.</p>
<p>Attention cette modification ne doit pas changer le comportement de la fonction, c'est-√†-dire si le texte entr√© n'est pas un nombre, il faut le
			redemander encore √† l'utilisateur jusqu'√† ce qu'un nombre correct soit entr√©.</p>
<p>Utilisez votre nouvelle fonction dans votre programme pour la tester.</p>
		
			<div class="correction">
<pre class="line-numbers"><code class="language-python">
					def avoir_nombre_utilisateur_exceptions(message):
						nb_est_correct = False
						while not nb_est_correct:
							txt_utilisateur = input(message)
							try:
								nombre = float(txt_utilisateur)
								nb_est_correct = True
							except:
								print(txt_utilisateur, "n'est pas un nombre")
						return nombre

					def avoir_nombre_utilisateur_verif_manuelle(message):
						txt_utilisateur_est_un_nombre = False
						while not txt_utilisateur_est_un_nombre:
							txt_utilisateur = input(message)
							indice_d√©part = 0
							signe = txt_utilisateur[indice_d√©part]
							virgule_rencontr√©e = False
							if signe == "-":
								indice_d√©part += 1
							txt_utilisateur_est_un_nombre = True
							for i in range(indice_d√©part, len(txt_utilisateur)):
								c = txt_utilisateur[i]
								if c == ".":
									if not virgule_rencontr√©e:
										virgule_rencontr√©e = True
									else:
										print(txt_utilisateur, "n'est pas un nombre")
										txt_utilisateur_est_un_nombre = False
										break
								elif c not in "0123456789":
									print(txt_utilisateur, "n'est pas un nombre")
									txt_utilisateur_est_un_nombre = False
									break

						return float(txt_utilisateur)


					# D√©finition de notre seconde fonction
					def faire_calcul_utilisateur():
						nb1 = avoir_nombre_utilisateur_verif_manuelle("Nombre 1: ")

						op√©ration_est_correcte = False
						while not op√©ration_est_correcte:
							op = input("Op√©ration (+,-,*,/): ")
							op√©ration_est_correcte = op in ["+", "-", "/", "*", ]
							if not op√©ration_est_correcte:
								print(op, "n'est pas une op√©ration support√©e")

						nb2 = avoir_nombre_utilisateur_verif_manuelle("Nombre 2: ")

						if op == "+":
							print(nb1, "+", nb2, "=", nb1 + nb2)
						elif op == "-":
							print(nb1, "-", nb2, "=", nb1 - nb2)
						elif op == "/":
							print(nb1, "/", nb2, "=", nb1 / nb2)
						else:
							print(nb1, "*", nb2, "=", nb1 * nb2)


					utilisateur_veut_continuer = True
					while utilisateur_veut_continuer:
						# Appel de la fonction
						faire_calcul_utilisateur()

						r√©ponse_utilisateur = input("Faire nouveau calcul? (o pour oui): ")
						utilisateur_veut_continuer = r√©ponse_utilisateur == "o"
				</code></pre>
</div>
		
	</div>


		<div class="nav_arrows" style=" margin-bottom: 1em;">

			<div style="text-align: center; opacity: 0.5; font-size: small">

			</div>
		</div>

	</div>

	
		<style>
			@media only screen and (min-width: 70em) {
				#side_nav_bar {
					width: 25vw;
				}

				#contenu {
					width: 75vw;
				}
			}
		</style>
	


</div>
  
<script src="prism.js"></script>

<script>
	if (document.URL.indexOf("localhost") === -1) {
		//console.log("pas localhost");
		document.querySelector("link[rel = 'icon']").setAttribute("href", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='200' height='200' viewBox='0 0 100 100' style='display:block; margin:auto; padding: 0 0 1em 0;'%3E%3Cstyle%3E text %7B text-align: center; fill: white; text-anchor: middle; font-size: 11pt; %3C/style%3E%3C!--	%3Crect fill='hsl(000,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E--%3E%3Crect fill='hsl(200,50%25, 50%25)' x='0' y='0' width='100' height='100'%3E%3C/rect%3E%3Ctext x='50' y='75' style='font-size: 50pt;' id='t'%3E üêç %3C/text%3E%3C!--	%3Canimate--%3E%3C!-- xlink:href='%23t'--%3E%3C!-- attributeName='y'--%3E%3C!-- calcMode='spline'--%3E%3C!-- values='60; 90; 60'--%3E%3C!-- keyTimes='0; 0.5; 1'--%3E%3C!-- keySplines='--%3E%3C!-- .42 0 1 1;--%3E%3C!-- 0 0 .59 1;'--%3E%3C!-- dur='2s'--%3E%3C!-- fill='freeze'--%3E%3C!-- repeatCount='indefinite'/%3E--%3E%3C/svg%3E");
	} else {
		//console.log("localhost");
	}
	// On supprime la premi√®re ligne des <pre><code> qui est consid√©r√©e toujours vide et inutile
	const codes = document.querySelectorAll('pre[class="affichage_console"] code');
	
	codes.forEach(function (el) {
		// Attention: modifier textContent ou innerText d'un √©l√©ment d√©truit tous ses √©l√©ments enfant :(
		//el.textContent = el.textContent.replace(/^\n/, '');
		// On modifie donc le premie noeud texte uniquement
		el.childNodes[0].textContent = el.childNodes[0].textContent.replace(/^\n/, ''); // suppose que c'est un √©l√©ment texte
	});

	// On ajoute un <br> avant et apr√®s chaque <pre>
	let pres = document.querySelectorAll('pre, .exercices div.not√©');
	pres.forEach(function (el) {
		el.parentNode.insertBefore(document.createElement('div'), el);
		el.parentNode.insertBefore(document.createElement('div'), el.nextSibling);
	});

	// On ajoute 'Affichage' avant chaque affichage console
	pres = document.querySelectorAll('pre[class="affichage_console"]');
	pres.forEach(function (el) {
		const p = document.createElement('p');
		p.innerHTML = `<small>‚Üì Affichage dans la console (ou dans le shell, selon o√π vous lancez l'ex√©cution)<mall>`;
		p.classList.add("l√©gende_plac√©e_en_haut");
		el.parentNode.insertBefore(p, el);
	});

	// Cacher corrections dans les TD / TP, et permettre de les afficher
	let divs_correction = document.querySelectorAll('div[class="correction"]');
	divs_correction.forEach(function (div) {
		div.classList.add("correction_hidden");
		const p = document.createElement('p');
		p.innerHTML = `<span class="correction_lien_√†_cliquer">üìù Afficher / cacher correction ‚úì</span>`;
		p.onclick = function (evt) {
			div.classList.toggle("correction_hidden");
		};
		div.parentNode.insertBefore(p, div);
	});
</script>
</body>
</html>